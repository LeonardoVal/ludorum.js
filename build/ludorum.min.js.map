{"version":3,"sources":["../src/__prologue__.js","../src/Player.js","../src/Game.js","../src/Match.js","../src/Contingent.js","../src/Tournament.js","../src/utils/Checkerboard.js","../src/utils/CheckerboardFromString.js","../src/utils/CheckerboardFromPieces.js","../src/utils/Scanner.js","../src/utils/Cache.js","../src/utils/GameTree.js","../src/players/RandomPlayer.js","../src/players/TracePlayer.js","../src/players/HeuristicPlayer.js","../src/players/MiniMaxPlayer.js","../src/players/MaxNPlayer.js","../src/players/AlphaBetaPlayer.js","../src/players/MonteCarloPlayer.js","../src/players/UCTPlayer.js","../src/players/RuleBasedPlayer.js","../src/players/EnsemblePlayer.js","../src/players/UserInterfacePlayer.js","../src/players/WebWorkerPlayer.js","../src/games/TicTacToe.js","../src/aleatories/Aleatory.js","../src/aleatories/DieAleatory.js","../src/__epilogue__.js","../src/aleatories/aleatories.js","../src/games/Predefined.js","../src/games/Choose2Win.js","../src/games/ConnectionGame.js","../src/games/OddsAndEvens.js","../src/games/ToadsAndFrogs.js","../src/games/Pig.js","../src/games/Mutropas.js","../src/games/Bahab.js","../src/games/Puzzle15.js","../src/tournaments/RoundRobin.js","../src/tournaments/Measurement.js","../src/tournaments/Elimination.js"],"names":["__init__","base","Sermat","__PlayerCount__","unimplemented","objects","obj","copy","raise","raiseIf","declare","Iterable","iterable","Future","Randomness","initialize","Statistics","Events","exports","__package__","__name__","__dependencies__","__SERMAT__","include","aleatories","games","players","tournaments","utils","Game","constructor","activePlayers","this","activatePlayers","name","moves","next","result","scores","results","view","player","isActive","i","arguments","length","indexOf","activePlayer","len","Array","isArray","opponents","filter","p","opponent","playerIndex","perform","possibleMoves","Object","keys","map","move","product","apply","mapApply","toArray","playerMoves","toObject","contingent","update","Contingent","randomNext","random","allMoves","randomMoves","forEach","choice","state","resultBounds","normalizedResult","bounds","zerosumResult","score","opponentScore","victory","defeat","tied","isZeroSum","isDeterministic","isSimultaneous","__hash__","hashCode","toString","clone","ser","static make","members","hasOwnProperty","static cacheProperties","clazz","prototype","slice","call","propertyName","cacheName","originalGetter","static serialized","game","super_moves","super_next","fixedMoves","__fixedMoves__","nextFixedMoves","all","Player","params","getPrototypeOf","string","defaultValue","coerce","object","DEFAULT","decision","role","movesFor","isCompatibleWith","participate","match","dual playTo","self","Match","static __SERMAT__","identifier","serializer","zip","history","events","ply","isNaN","decisions","then","run","plys","Infinity","when","onBegin","__advanceContingents__","onEnd","__advance__","haps","isContingent","randomHaps","push","onNext","__command__","static commands","Quit","onQuit","emit","logger","info","attr","join","JSON","stringify","static randomMatch","args","m","RandomPlayer","playTo","log","Logger","appendToConsole","materializer","n","h","randomValue","possibleHaps","hap","distribution","v","prob","expectedEvaluation","stateEvaluation","aggregation","isAsync","possible","game2","ev","__isFuture__","r","triple","Tournament","iterables","statistics","tournament","doWhile","beforeMatch","__runMatch__","account","afterMatch","bind","stats","playerResult","add","key","entry","debug","Checkerboard","height","width","emptySquare","isValidCoord","coord","coordinates","range","square","isEmptySquare","horizontals","row","column","verticals","orthogonals","chain","positiveDiagonals","count","Math","max","min","j","negativeDiagonals","diagonals","lines","sublines","line","flatten","walk","delta","board","current","STOP_ITERATION","walks","deltas","static DIRECTIONS","HORIZONTAL","VERTICAL","ORTHOGONAL","DIAGONAL","EVERY","__place__","place","value","__move__","coordFrom","coordTo","valueLeft","__swap__","valueTo","swap","transform","coordinateMapping","position","newPosition","concat","horizontalSymmetry","verticalSymmetry","clockwiseRotation","counterClockwiseRotation","renderAsHTMLTable","document","container","callback","table","createElement","appendChild","reverse","tr","td","data","id","className","innerHTML","Text","escapeXML","onclick","weightedSum","weights","coefficients","weight","sum","CheckerboardFromString","charAt","Error","repeat","substr","outside","asString","asStrings","asRegExp","insideLine","outsideLine","squares","asRegExps","undefined","CheckerboardFromPieces","pieces","piece","select","Scanner","config","ignore","integer","bool","scan","scanner","window","__currentWidth__","maxLength","whileDo","level","nexts","isEmpty","adjustWidth","sample","scans","sequence","EMPTY","decisionTime","stat","startTime","addTime","static scan","Cache","clear","root","stateIdentifier","moveIdentifier","has","stateId","__entries__","get","size","_entry","precursors","descendants","descendant","movesId","nextState","nextStateId","nextEntry","__root__","prune","pending","pruned","shift","pair","GameTree","parent","transition","probability","children","possibleTransitions","Cons","t","childrenCount","__expandChild__","child","err","expand","expandRandom","expandAll","serializeAsProperties","TracePlayer","trace","__iter__","__decision__","catchStop","HeuristicPlayer","func","moveEvaluation","heuristicPlayer","ms","gameResult","heuristic","evaluatedMoves","e","bestMoves","greater","static composite","components","MiniMaxPlayer","MaxNPlayer","horizon","maxN","heuristics","quiescence","depth","values","otherValues","options","minimax","NaN","expectiMinimax","comparison","hook","hookValue","static solution","evals","mmPlayer","gameKey","k","AlphaBetaPlayer","alpha","beta","MonteCarloPlayer","number","simulationCount","timeCap","agent","monteCarloPlayer","Date","now","__finishMoveEvaluation__","option","sim","simulation","plies","simCount","resultSum","q","UCTPlayer","explorationConstant","sqrt","selectNode","totalSimulationCount","node","uct","visits","rewards","simulationResult","console","RuleBasedPlayer","array","features","rules","rule","f","static regExpRule","regExp","test","regExpRule","EnsemblePlayer","playerSelection","randomDecision","heuristicCombination","average","ds","d","__bestAggregatedEvaluationMove__","__aggregateEvaluatedMoves__","grouped","groupAll","evm","evs","aggregated","static parallelizeHeuristicPlayer","amount","webWorkerParams","navigator","hardwareConcurrency","fs","ludorum","WebWorkerPlayer","create","UserInterfacePlayer","__future__","isPending","resolve","commands","action","future","UserInterface","show","off","on","display","actionRole","BasicHTMLInterface","global","getElementById","firstChild","removeChild","build","nodes","ui","element","attrs","attrName","setAttribute","createTextNode","worker","onmessage","Parallel","__onmessage__","static createWorker","playerBuilder","workerSetup","parallel","deps","dependencies","dependency","loadModule","__parallel__","static create","createWorker","__newFuture__","cancelValue","__cancelValue__","reject","msg","parse","error","__run__","code","commandQuit","postMessage","MAPPINGS","Aleatory","__distribution__","weightedChoice","alea","static tries","combinations","math","pow","static aggregate","dist1","dist2","comb","eq","distR","v1","v2","forEachApply","p1","p2","DieAleatory","randomInt","dice","D4","D6","D8","D10","D12","D20","uniformAleatory","normalization","probSum","sumProbability","s","factorial","fact_n","fact_n_1","floor","comb1","x","comb2","Predefined","__results__","A","B","Choose2Win","turns","winner","__turns__","__winner__","draw","win","lose","pass","ConnectionGame","lineLength","__lines__","CACHE","__result__","__moves__","nextPlayer","nextBoard","OddsAndEvens","points","Evens","Odds","pointDifference","parity","TicTacToe","WIN_X","WIN_O","chr","substring","VALUE","_","X","O","parseInt","split","equivalent","str","syms","sym","sort","printBoard","static heuristics","heuristicFromWeights","weightSum","abs","__heuristic__","playerChar","","board3x3","RegExp","defaultHeuristic","ToadsAndFrogs","static board","chips","separation","replace","T","F","Pig","goal","rolls","__scores__","__rolls__","currentScore","score0","score1","nextScores","nextRolls","roll","die","Mutropas","playedPieces","dealPieces","allPieces","piecesPerPlayer","split1","split2","moveResult","piece1","piece2","upperBound","player0","player1","__viewNext__","move0","move1","nextPlayedPieces","nextPieces","__possiblePieces__","opponentPieces","possiblePieces","Bahab","initialBoard","__PLAYER_ENDGAME_RE__","Uppercase","Lowercase","__PLAYER_PIECES_RE__","pieceRegExp","_moves","pieceMoves","dx","dy","squareTo","toLowerCase","Puzzle15","target","maxMoves","randomBoard","moveNumber","rng","symbols","toUpperCase","shuffle","differences","emptyCoord","pos","DIRECTIONS","dr","dc","RoundRobin","matchCount","__matches__","permutations","tuple","Measurement","playerCount","opponentCombinations","splice","Elimination","__bracket__","roleCount","participants","unshift","pop","__playoff__","matches","playoffResult","matchResult","playerName","winnerName","__currentBracket__","type"],"mappings":"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","file":"ludorum.min.js","sourcesContent":["/** Library wrapper and layout.\n*/\nfunction __init__(base, Sermat) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar unimplemented = base.objects.unimplemented,\n\t\tobj = base.obj,\n\t\tcopy = base.copy,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tdeclare = base.declare,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tFuture = base.Future,\n\t\tRandomness = base.Randomness,\n\t\tinitialize = base.initialize,\n\t\tStatistics = base.Statistics,\n\t\tEvents = base.Events;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t\t__package__: 'ludorum',\n\t\t\t__name__: 'ludorum',\n\t\t\t__init__: __init__,\n\t\t\t__dependencies__: [base, Sermat],\n\t\t\t__SERMAT__: { include: [base] }\n\t\t},\n\t\t/** The library is organized in the following _namespaces_.\n\t\t*/\n\t\taleatories = exports.aleatories = {},\n\t\tgames = exports.games = {},\n\t\tplayers = exports.players =  {},\n\t\ttournaments = exports.tournaments = {},\n\t\tutils = exports.utils = {}\n\t;","/** # Player\n\nPlayer is the base type for all playing agents. Basically, playing a game means choosing a move from \nall available ones, each time the game enables the player to do so.\n*/\nvar Player = exports.Player = declare({\n\t/** The default constructor takes only its `name` from the given `params`. This is an abstract \n\tclass that is meant to be extended.\n\t*/\n\tconstructor: (function () {\n\t\tvar __PlayerCount__ = 0; // Used by the Player's default naming.\n\t\treturn function Player(params) {\n\t\t\tvar prototype = Object.getPrototypeOf(this);\n\t\t\tinitialize(this, params)\n\t\t\t\t.string('name', { defaultValue: 'Player' + (__PlayerCount__++), coerce: true })\n\t\t\t\t.object('random', { defaultValue: prototype.random });\n\t\t};\n\t})(),\n\n\trandom: Randomness.DEFAULT,\n\n\t/** A player is asked to choose a move by calling `Player.decision(game, role)`. The result is \n\tthe selected move if it can be obtained synchronously, else a future is returned.\n\t*/\n\tdecision: function decision(game, role) {\n\t\treturn this.movesFor(game, role)[0]; // Indeed not a very thoughtful base implementation. \n\t},\n\n\t/** To help implement the decision, `Player.movesFor(game, player)` gets the moves in the game \n\tfor the player. It also checks if there are any moves, and if it not so an error is risen.\n\t*/\n\tmovesFor: function movesFor(game, role) {\n\t\tvar moves = game.moves();\n\t\traiseIf(!moves || !moves[role] || moves[role].length < 1, \n\t\t\t\"Player \", role, \" has no moves for game \", game, \".\");\n\t\treturn moves[role];\n\t},\n\t\n\t/** Not all players can be used to play with all games. Still, by default the result of \n\t`isCompatibleWith` is `true`.\n\t*/\n\tisCompatibleWith: function isCompatibleWith(game) {\n\t\treturn true;\n\t},\n\t\n\t/** Before starting a [match](Match.js.html), all players are asked to join by calling \n\t`Player.participate(match, role)`. This allows the player to prepare properly. If this implies \n\tbuilding another instance of the player object, it must be returned in order to participate in \n\tthe match.\n\t*/\n\tparticipate: function participate(match, role) {\n\t\treturn this;\n\t},\n\t\n\t// ## Utilities ################################################################################\n\t\n\t/** `make` is a shortcut for making a subclass of `Player`.\n\t*/\n\t'static make': function make(members) {\n\t\treturn declare(this, members);\n\t},\n\n\t/** The `playTo` method makes a match for the given `game` where all roles are played by this\n\tagent.\n\t*/\n\t'dual playTo': function playTo(game) {\n\t\tvar self = this,\n\t\t\tplayers = game.players.map(function (role) {\n\t\t\t\treturn typeof self === 'function' ? new self() : self;\n\t\t\t});\n\t\treturn new Match(game, players);\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Player',\n\t\tserializer: function serialize_Player(obj) {\n\t\t\treturn [{name: obj.name}];\n\t\t}\n\t},\n\t\n\t/** The string representation of the player is derived straight from its serialization.\n\t*/\n\ttoString: function toString() {\n\t\treturn Sermat.ser(this);\n\t}\n}); // declare Player.\n","/** # Game\n\nThe class `ludorum.Game` is the base type for all games.\n*/\nvar Game = exports.Game = declare({\n\t/** Its constructor takes the active player/s. A player is active if and only if it can move.\n\tThe argument may be either a player's name (string) or an array of players' names. It is used to\n\tinitialize `Game.activePlayers`, an array with the active players' names.\n\t*/\n\tconstructor: function Game(activePlayers) {\n\t\tthis.activatePlayers(activePlayers);\n\t},\n\n\t/** The game's `name` is used mainly for displaying purposes.\n\t*/\n\tname: '?',\n\n\t/** The game `players` are specified in an array of role names (strings), that the players can\n\tassume in a match of this game. For example: `\"Xs\"` and `\"Os\"` in TicTacToe, or `\"Whites\"` and\n\t`\"Blacks\"` in Chess.\n\t*/\n\tplayers: [],\n\n\t/** The moves of each active player are calculated by `moves()`. This method returns an object\n\twith every active player related to the moves each can make in this turn. For example:\n\n\t+ `{ Player1: ['Rock', 'Paper', 'Scissors'], Player2: ['Rock', 'Paper', 'Scissors'] }`\n\n\tIf the game has finished then a _falsy_ value must be returned (`null` is recommended).\n\t*/\n\tmoves: unimplemented(\"Game\", \"moves()\"),\n\n\t/** Once the players have chosen their moves, the method `next` is used to perform the given\n\tmoves. The first `moves` argument should be an object with a move for each active player. For\n\texample:\n\n\t+ `{ Player1: 'Rock', Player2: 'Paper' }`\n\n\tA second argument `haps` may be added if the game has random variables. It must have the same\n\tform as the `moves` argument, but instead of players as keys it will have random variables as\n\tkeys.\n\n\t+ `{ die1: 6, die2: 3 }`\n\n\tIf the third argument `update` is true indicate that is not necessary to return a new game\n\tinstance. Else (and by default) the returned resulting state is always a new game instance.\n\n\tThere isn't a default implementation of `next`, so it must be overriden. It is strongly advised\n\tto check if the arguments are valid.\n\t*/\n\tnext: unimplemented(\"Game\", \"next(moves, haps, update)\"),\n\n\t/** If the game is finished the result of the game is calculated with `result()`. It returns an\n\tobject with every player in the game related to a number. This number must be positive if the\n\tplayer wins, negative if the player loses or zero if the game is a tie. For example:\n\n\t+ `{ Player1: -1, Player2: +1 }`\n\n\tIf the game is not finished, this function must return a _falsy_ value (`null` is recommended).\n\t*/\n\tresult: unimplemented(\"Game\", \"result()\"),\n\n\t/** Some games may assign scores to the players in a finished game. This may differ from the\n\tresult, since the score sign doesn't have to indicate victory or defeat. For example:\n\n\t+ result: `{ Player1: -1, Player2: +1 }`\n\t+ scores: `{ Player1: 14, Player2: 15 }`\n\n\tThe method `scores()` returns the scores if such is the case. Also the score may be defined for\n\tunfinished games.\n\n\tBy default, it return the same that `result()` does.\n\t*/\n\tscores: function scores() {\n\t\treturn this.results();\n\t},\n\n\t/** In incomplete or imperfect information games players have different access to the game state\n\tdata. The method `view(player)` returns a modified version of this game, that shows only the\n\tinformation from the perspective of the given player. The other information is modelled as\n\taleatory variables.\n\n\tIn this way searches in the game tree can be performed without revealing to\tthe automatic player\n\tinformation it shouldn't have access to (a.k.a _cheating_).\n\t*/\n\tview: function view(player) {\n\t\treturn this;\n\t},\n\n\t// ## Player information #######################################################################\n\n\t/** Method `isActive(player...)` checks if the given players are all active.\n\t*/\n\tisActive: function isActive() {\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tif (this.activePlayers.indexOf(arguments[i]) < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t/** In most games there is only one active player per turn. The method `activePlayer()` returns\n\tthat active player's role if there is one and only one, else it raises an error.\n\t*/\n\tactivePlayer: function activePlayer() {\n\t\tvar len = this.activePlayers.length;\n\t\traiseIf(len < 1, 'There are no active players!');\n\t\traiseIf(len > 1, 'More than one player is active!');\n\t\treturn this.activePlayers[0];\n\t},\n\n\t/** Sets the `activePlayers` of this game state. Since this method changes the current game\n\tstate, use with care.\n\t*/\n\tactivatePlayers: function activatePlayers(activePlayers) {\n\t\treturn this.activePlayers = !activePlayers ? [this.players[0]] :\n\t\t\t(!Array.isArray(activePlayers) ? [activePlayers] : activePlayers);\n\t},\n\n\t/** All players in a game are assumed to be opponents. The method `opponents(players=activePlayers)`\n\treturns an array with the opponent roles of the given players, or of the active players by\n\tdefault. If not all players are opponents this method can be overriden.\n\t*/\n\topponents: function opponents(players) {\n\t\tplayers = players || this.activePlayers;\n\t\treturn this.players.filter(function (p) {\n\t\t\treturn players.indexOf(p) < 0;\n\t\t});\n\t},\n\n\t/** Since most games have only two players, the method `opponent(player=activePlayer)`\n\tconveniently returns the opponent of the given player, or the active player by default.\n\t*/\n\topponent: function opponent(player) {\n\t\tvar playerIndex = this.players.indexOf(player || this.activePlayer());\n\t\treturn this.players[(playerIndex + 1) % this.players.length];\n\t},\n\n\t// ## Game flow ################################################################################\n\n\t/** Since `next()` expects a moves object, the method `perform(move, player=activePlayer, ...)`\n\tpretends to simplify simpler game mechanics. It performs the given moves for the given players\n\t(activePlayer by default) and returns the next game state.\n\t*/\n\tperform: function perform() {\n\t\tvar moves = {}, player;\n\t\tfor (var i = 0; i < arguments.length; i += 2) {\n\t\t\tplayer = arguments[i + 1];\n\t\t\tif (typeof player === 'undefined') {\n\t\t\t\tplayer = this.activePlayer();\n\t\t\t}\n\t\t\tmoves[player] = arguments[i];\n\t\t}\n\t\treturn this.next(moves);\n\t},\n\n\t/** The method `moves()` returns the available moves for each player. Yet this is not the same\n\tas the `moves` objects that can be used with `next()` to obtain a next game state. Furthermore,\n\tif there are more than one active player per turn, the possible decisions can be build with all\n\tcombinations for all active players.\n\n\tThe method `possibleMoves(moves=this.moves())` calculates all possible `moves` objects based on\n\tthe result of `moves()`. For example, if `moves()` returns `{A:[1,2], B:[3,4]}`, then\n\t`possibleMoves()` would return `[{A:1, B:3}, {A:1, B:4}, {A:2, B:3}, {A:2, B:4}]`.\n\t*/\n\tpossibleMoves: function possibleMoves(moves) {\n\t\tmoves = arguments.length < 1 ? this.moves() : moves;\n\t\tif (!moves || typeof moves !== 'object') {\n\t\t\treturn [];\n\t\t}\n\t\tvar activePlayers = Object.keys(moves);\n\t\tif (activePlayers.length === 1) { // Most common case.\n\t\t\tvar activePlayer = activePlayers[0];\n\t\t\treturn moves[activePlayer].map(function (move) {\n\t\t\t\treturn obj(activePlayer, move);\n\t\t\t});\n\t\t} else { // Simultaneous games.\n\t\t\treturn Iterable.product.apply(Iterable,\n\t\t\t\titerable(moves).mapApply(function (player, moves) {\n\t\t\t\t\treturn moves.map(function (move) {\n\t\t\t\t\t\treturn [player, move];\n\t\t\t\t\t});\n\t\t\t\t}).toArray()\n\t\t\t).map(function (playerMoves) {\n\t\t\t\treturn iterable(playerMoves).toObject();\n\t\t\t}).toArray();\n\t\t}\n\t},\n\n\t/** Game states that depend on random variables are `Contingent` game states. The `contingent`\n\tmethod is a shortcut to make such states based on the current game state.\n\t*/\n\tcontingent: function contingent(moves, aleatories, update) {\n\t\treturn new Contingent(this, moves, aleatories, update);\n\t},\n\n\t/** A `randomNext` picks one of the next states at random.\n\t*/\n\trandomNext: function randomNext(random, update) {\n\t\tvar allMoves = this.moves(),\n\t\t\trandomMoves = {};\n\t\tthis.activePlayers.forEach(function (activePlayer) {\n\t\t\trandomMoves[activePlayer] = random.choice(allMoves[activePlayer]);\n\t\t});\n\t\treturn {\n\t\t\tstate: this.next(randomMoves, null, update),\n\t\t\tmoves: randomMoves\n\t\t};\n\t},\n\n\t// ## Result functions #########################################################################\n\n\t/** The maximum and minimum results may be useful and even required by some game search\n\talgorithm. To expose these values, `resultBounds()` returns an array with first the minimum and\n\tthen the maximum. Most game have one type of victory (+1) and one type of defeat (-1). That's\n\twhy `resultBounds()` returns [-1,+1] by default. Yet some games can define different bounds by\n\toverriding it.\n\t*/\n\tresultBounds: function resultBounds() {\n\t\treturn [-1,+1];\n\t},\n\n\t/** The `normalizedResult(result=this.result())` is the `result()` expressed so the minimum\n\tdefeat is equal to -1 and the maximum victory is equal to +1.\n\t*/\n\tnormalizedResult: function normalizedResult(result) {\n\t\tresult = result || this.result();\n\t\tvar bounds;\n\t\tif (result && typeof result === 'object') {\n\t\t\tbounds = this.resultBounds();\n\t\t\tresult = base.copy(result);\n\t\t\tfor (var player in result) {\n\t\t\t\tresult[player] = (result[player] - bounds[0]) / (bounds[1] - bounds[0]) * 2 - 1;\n\t\t\t}\n\t\t\treturn result;\n\t\t} else if (typeof result === 'number') {\n\t\t\tbounds = this.resultBounds();\n\t\t\treturn (+result - bounds[0]) / (bounds[1] - bounds[0]) * 2 - 1;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\n\t/** Most games have victory and defeat results that cancel each other. It is said that all the\n\tvictors wins the defeated player loses. Those games are called _zerosum games_. The method\n\t`zerosumResult(score, players=activePlayers)` builds a game result object for a zerosum game.\n\tThe given score is split between the given players (the active players by default), and (-score)\n\tis split between their opponents.\n\t*/\n\tzerosumResult: function zerosumResult(score, players) {\n\t\tplayers = !players ? this.activePlayers : (!Array.isArray(players) ? [players] : players);\n\t\tscore = (+score) / (players.length || 1);\n\t\tvar opponentScore = -score / (this.players.length - players.length || 1);\n\t\treturn iterable(this.players).map(function (player) {\n\t\t\treturn [player, players.indexOf(player) < 0 ? opponentScore : score];\n\t\t}).toObject();\n\t},\n\n\t/** There are two shortcuts for `zerosumResult()`. First `victory(players=activePlayers, score=1)`\n\treturns the zero-sum game result with the given players (or the active players by default) as\n\twinners, and their opponents as losers.\n\t*/\n\tvictory: function victory(players, score) {\n\t\treturn this.zerosumResult(score || 1, players);\n\t},\n\n\t/** Second `defeat(players=activePlayers, score=-1)` returns the zero-sum game result with the\n\tgiven players (or the active players by default) as losers, and their opponents as winners.\n\t*/\n\tdefeat: function defeat(players, score) {\n\t\treturn this.zerosumResult(score || -1, players);\n\t},\n\n\t/** Finally `tied(players=this.players, score=0)` returns the game result of a tied game with\n\tthe given players (or the active players by default) all with the same score (zero by default).\n\tA tied game must always have the same result for all players.\n\t*/\n\ttied: function tied(players, score) {\n\t\tscore = +(score || 0);\n\t\treturn iterable(players || this.players).map(function (p) {\n\t\t\treturn [p, score];\n\t\t}).toObject();\n\t},\n\n\t// ## Game information #########################################################################\n\n\t/** Some AI algorithms have constraints on which games they can support. A game can provide some\n\tinformation to assess its compatibility with an artificial player automaticaly. Properties may\n\tinclude:\n\n\t+ `isZeroSum`: The sum of all results in every match is zero. True by default.\n\t*/\n\tisZeroSum: true,\n\n\t/** + `isDeterministic`: Perfect information game without random variables. False by default.\n\t*/\n\tisDeterministic: false,\n\n\t/** + `isSimultaneous`: In some or all turns more than one player is active. False by default.\n\t*/\n\tisSimultaneous: false,\n\n\t// ## Conversions & presentations ##############################################################\n\n\t/** Some algorithms require a `__hash__()` for each game state, in order to store them in caches\n\tor hash tables. The default implementation uses `Sermat.hashCode`.\n\t*/\n\t__hash__: function __hash__() {\n\t\treturn Sermat.hashCode(this).toString(36);\n\t},\n\n\t/** Based on the game's serialization, `clone()` creates a copy of this game state.\n\t*/\n\tclone: function clone() {\n\t\treturn Sermat.clone(this);\n\t},\n\n\t/** The default string representation of a game is equal to its serialization with Sermat.\n\t*/\n\ttoString: function toString() {\n\t\treturn Sermat.ser(this);\n\t},\n\n\t// ## Game implementation #####################################################################\n\n\t/** `make` is a shortcut for making a subclass of `Game`.\n\t*/\n\t'static make': function make(members) {\n\t\tmembers = copy({}, members);\n\n\t\tif (!members.hasOwnProperty('name') && typeof members.constructor === 'function') {\n\t\t\tmembers.name = members.constructor.name;\n\t\t}\n\t\traiseIf(typeof members.name !== 'string' || !members.name, \"A game must have a `name`!\");\n\t\traiseIf(!Array.isArray(members.players), \"A game must have `players`!\");\n\t\treturn declare(this, members);\n\t},\n\n\t/** `cacheProperties` modifies getter methods (like `moves()` or `result()`) to cache its\n\tresults. Warning! Caching the results of the `next()` method may lead to memory leaks or\n\toverload.\n\t*/\n\t'static cacheProperties': function cacheProperties() {\n\t\tvar clazz = this;\n\t\tArray.prototype.slice.call(arguments).forEach(function (propertyName) {\n\t\t\tvar cacheName = '__'+ propertyName +'$cache__',\n\t\t\t\toriginalGetter = clazz.prototype[propertyName];\n\t\t\tclazz.prototype[propertyName] = function () {\n\t\t\t\tif (arguments.length > 0) {\n\t\t\t\t\treturn originalGetter.apply(this, arguments);\n\t\t\t\t} else if (!this.hasOwnProperty(cacheName)) {\n\t\t\t\t\tthis[cacheName] = originalGetter.call(this);\n\t\t\t\t}\n\t\t\t\treturn this[cacheName];\n\t\t\t};\n\t\t});\n\t\treturn clazz;\n\t}, // static cacheProperties\n\n\t/** `serialized(game)` builds a serialized version of a simultaneous game, i.e. one in which two\n\tor more players may be active in the same turn. It converts a simultaneous game to an alternated\n\tturn based game. This may be useful for using algorithms like MiniMax to build AIs for\n\tsimultaneous games.\n\t*/\n\t'static serialized': function serialized(game) {\n\t\tvar super_moves = game.prototype.moves,\n\t\t\tsuper_next = game.prototype.next;\n\t\treturn declare(game, {\n\t\t\t/** The `moves()` of a serialized game returns the moves of the player deemed as the\n\t\t\tactive player, if there are any moves.\n\t\t\t*/\n\t\t\tmoves: function moves() {\n\t\t\t\tvar fixedMoves = this.__fixedMoves__ || (this.__fixedMoves__ = {}),\n\t\t\t\t\tallMoves = super_moves.call(this),\n\t\t\t\t\tactivePlayer;\n\t\t\t\tfor (var i = 0; i < this.activePlayers.length; i++) {\n\t\t\t\t\tif (fixedMoves.hasOwnProperty(this.activePlayers[i])) {\n\t\t\t\t\t\tactivePlayer = this.activePlayers[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn activePlayer && allMoves ? obj(activePlayer, allMoves[activePlayer]) : null;\n\t\t\t},\n\n\t\t\t/** The `next(moves)` of a serialized game advances the actual game if with the given\n\t\t\tmove all active players in the real game state have moved. Else the next player that has\n\t\t\tto move becomes active.\n\t\t\t*/\n\t\t\tnext: function next(moves) {\n\t\t\t\tvar nextFixedMoves = copy({}, this.fixedMoves || {}, moves),\n\t\t\t\t\tallMoved = iterable(this.players).all(function (p) {\n\t\t\t\t\t\t\treturn nextFixedMoves.hasOwnProperty(p);\n\t\t\t\t\t\t}),\n\t\t\t\t\tresult;\n\t\t\t\tif (allMoved) {\n\t\t\t\t\tresult = super_next.call(this, nextFixedMoves);\n\t\t\t\t\tresult.fixedMoves = {};\n\t\t\t\t} else {\n\t\t\t\t\tresult = this.clone();\n\t\t\t\t\tresult.fixedMoves = nextFixedMoves;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t} // static serialized\n\n}); // declare Game.\n","/** # Match\n\nA match is a controller for a game, managing player decisions, handling the flow of the turns\nbetween the players by following the game's logic.\n*/\nvar Match = exports.Match = declare({\n\t/** `Match` objects are build with the [game's](Game.html) starting state and the players that\n\tparticipate. The players argument must be either an array of [`Player`](Player.html) objects or\n\tan object with a member for each of the game's players with a Player object as value.\n\t*/\n\tconstructor: function Match(game, players) {\n\t\tthis.game = game;\n\t\tthis.players = Array.isArray(players) ? iterable(game.players).zip(players).toObject() : players;\n\t\t/** The match records the sequence of game states in `Match.history`.\n\t\t*/\n\t\tthis.history = [ { state: game }];\n\t\tthis.events = new Events({\n\t\t\tevents: ['begin', 'next', 'end', 'quit']\n\t\t});\n\t\tfor (var p in this.players) { // Participate the players.\n\t\t\tthis.players[p] = this.players[p].participate(this, p) || this.players[p];\n\t\t}\n\t},\n\n\t/** Each step in the match's history is called a ply. `Match.ply()` indicates the current ply\n\tnumber.\n\t*/\n\tply: function ply() {\n\t\treturn this.history.length - 1;\n\t},\n\n\t/** Each ply has a game state. `Match.state(ply=last)` retrieves the game state for the given\n\tply, or the last one by default.\n\t*/\n\tstate: function state(ply) {\n\t\tply = isNaN(ply) ? this.ply() : +ply < 0 ? this.ply() + (+ply) : +ply;\n\t\treturn this.history[ply | 0].state;\n\t},\n\n\t/** If the last game state is finished, then the whole match is finished. If so,\n\t`Match.result()` returns the match result, which is the result of the last game state.\n\t*/\n\tresult: function result() {\n\t\treturn this.state().result();\n\t},\n\n\t/** If the last game state is not finished, then the match continues. To move the play on,\n\t`Match.decisions(game=state())` asks the active players in the game to choose their moves.\n\tReturns a future that is resolved when all players have decided.\n\t*/\n\tdecisions: function decisions(game) {\n\t\tgame = game || this.state();\n\t\tvar match = this,\n\t\t\tplayers = this.players,\n\t\t\tactivePlayers = game.activePlayers;\n\t\treturn Future.all(activePlayers.map(function (p) {\n\t\t\treturn players[p].decision(game.view(p), p);\n\t\t})).then(function (decisions) {\n\t\t\tvar moves = iterable(activePlayers).zip(decisions).toObject();\n\t\t\treturn moves;\n\t\t});\n\t},\n\n\t/** `Match.run(plys=Infinity)` runs the match the given number of plys, or until the game\n\tfinishes. The result is a future that gets resolved when the game ends.\n\t*/\n\trun: function run(plys) {\n\t\tplys = isNaN(plys) ? Infinity : +plys;\n\t\tif (plys < 1) { // If the run must stop...\n\t\t\treturn Future.when(this);\n\t\t}\n\t\tvar ply = this.ply(),\n\t\t\tgame = this.state(),\n\t\t\tresults, next;\n\t\tif (ply < 1) {\n\t\t\tthis.onBegin(game);\n\t\t}\n\t\tgame = this.__advanceContingents__(game); // Remove all non-determinism.\n\t\tresults = game.result();\n\t\tif (results) { // If the match has finished ...\n\t\t\tthis.onEnd(game, results);\n\t\t\treturn Future.when(this);\n\t\t} else { // Else the run must continue ...\n\t\t\tvar match = this;\n\t\t\treturn this.decisions(game).then(function (moves) {\n\t\t\t\tif (match.__advance__(game, moves)) {\n\t\t\t\t\treturn match.run(plys - 1);\n\t\t\t\t} else {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t__advanceContingents__: function __advanceContingents__(game) {\n\t\tvar haps, next;\n\t\twhile (game.isContingent) {\n\t\t\thaps = game.randomHaps();\n\t\t\tthis.history[this.history.length - 1].haps = haps;\n\t\t\tnext = game.next(haps);\n\t\t\tthis.history.push({ state: next });\n\t\t\tthis.onNext(game, null, haps, next);\n\t\t\tgame = next;\n\t\t}\n\t\treturn game;\n\t},\n\n\t__advance__: function __advance__(game, moves) {\n\t\tvar match = this,\n\t\t\tabortMatch = !iterable(game.activePlayers).all(function (player) {\n\t\t\t\tvar move = moves[player];\n\t\t\t\treturn typeof move.__command__ !== 'function' || move.__command__(match, player);\n\t\t\t});\n\t\tif (abortMatch) {\n\t\t\treturn false;\n\t\t}\n\t\tvar next = game.next(moves); // Match must go on.\n\t\tthis.history[this.history.length - 1].moves = moves;\n\t\tthis.history.push({ state: next });\n\t\tthis.onNext(game, moves, null, next);\n\t\treturn true;\n\t},\n\n\t/** ## Commands ################################################################################\n\n\tCommands are pseudo-moves, which can be returned by the players instead of valid moves for the\n\tgame being played. Their intent is to control the match itself.\n\n\tThe available commands are:\n\t*/\n\t\"static commands\": {\n\t\t/** + `Quit`: A quit command means the player that issued it is leaving the match. The match\n\t\tis then aborted.\n\t\t*/\n\t\tQuit: declare({\n\t\t\t__command__: function __command__(match, player) {\n\t\t\t\tmatch.onQuit(match.state(), player);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t})\n\t},\n\n\t/** ## Events ##################################################################################\n\n\tMatches provide game events that players and spectators can be registered to. `Match.events` is\n\tthe event handler. Emitted events are:\n\t*/\n\n\t/** + The `begin` event fired by `Match.onBegin(game)` when the match begins. The callbacks\n\tshould have the signature `function (game, match)`.\n\t*/\n\tonBegin: function onBegin(game) {\n\t\tthis.events.emit('begin', game, this);\n\t\tif (this.logger) {\n\t\t\tthis.logger.info('Match begins with ', iterable(this.players).map(function (attr) {\n\t\t\t\treturn attr[1] +' as '+ attr[0];\n\t\t\t}).join(', '), '; for ', game, '.');\n\t\t}\n\t},\n\n\t/** + The `next` event fired by `Match.onNext(game, next)` signals when the match advances to\n\tthe next game state. This may be due to moves or aleatory instantiation.  The callbacks should\n\thave the signature `function (gameBefore, gameAfter, match)`.\n\t*/\n\tonNext: function onNext(game, moves, haps, next) {\n\t\tthis.events.emit('next', game, moves, haps, next, this);\n\t\tif (this.logger) {\n\t\t\tthis.logger.info('Match advances from ', game, ' to ', next);\n\t\t}\n\t},\n\n\t/** + The `end` event triggered by `Match.onEnd(game, results)` notifies when the match ends.\n\tThe callbacks should have the signature `function (game, result, match)`.\n\t*/\n\tonEnd: function onEnd(game, results) {\n\t\tthis.events.emit('end', game, results, this);\n\t\tif (this.logger) {\n\t\t\tthis.logger.info('Match for ', game, 'ends with ', JSON.stringify(results));\n\t\t}\n\t},\n\n\t/** + The `quit` event triggered by `Match.onQuit(game, player)` is emitted when the match is\n\taborted due to the given player leaving it. The callbacks should have the signature\n\t`function (game, quitter, match)`.\n\t*/\n\tonQuit: function onQuit(game, player) {\n\t\tthis.events.emit('quit', game, player, this);\n\t\tif (this.logger) {\n\t\t\tthis.logger.info('Match for ', game, ' aborted because player '+ player +' quitted.');\n\t\t}\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** A `randomMatch` is a match for the given `game` played by random players (`RandomPlayer`).\n\t*/\n\t'static randomMatch': function randomMatch(game, args) {\n\t\targs = args || {};\n\t\tvar m = players.RandomPlayer.playTo(game);\n\t\tif (args.log) {\n\t\t\tif (typeof args.log ===  'object') {\n\t\t\t\tm.logger = args.log;\n\t\t\t} else {\n\t\t\t\tm.logger = new base.Logger(typeof args.log === 'string' ? args.log : 'Match');\n\t\t\t\tm.logger.appendToConsole();\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t},\n\n\ttoString: function toString() {\n\t\treturn Sermat.ser(this);\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Match',\n\t\tserializer: function serialize_Match(obj) {\n\t\t\treturn [obj.game, obj.players, obj.history];\n\t\t},\n\t\tmaterializer: function materialize_Match(obj, args) {\n\t\t\tif (args) {\n\t\t\t\tvar match = new Match(args[0], args[1]);\n\t\t\t\tmatch.history = args[2];\n\t\t\t\treturn match;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}); // declare Match.\n","/** # Contingent\n\nContingent states are game states that depend on other factors that the players choices. They are\nused to represent randomness in non-deterministic games. The random variables (called `haps`) can\nbe dice, card decks, roulettes, etc.\n*/\nvar Contingent = exports.Contingent = declare({\n\t/** Flag to distinguish contingent states from normal game states.\n\t*/\n\tisContingent: true,\n\n\t/** The default implementation takes a set of `haps`, a game `state` and a set of `moves`. See\n\tthe `next` method for further details.\n\t*/\n\tconstructor: function Contingent(state, moves, haps, update) {\n\t\tthis.state = state;\n\t\tthis.moves = moves;\n\t\t/** A contingent state's `haps` are the equivalent of `moves` in normal game states. The\n\t\tmethod returns an object with the random variables on which this node depends, e.g.:\n\t\t`{ die: aleatories.dice.D6 }`.\n\t\t*/\n\t\tthis.haps = haps;\n\t\tthis.update = !!update;\n\t},\n\n\t/** Contingent game states' `next` and `advance` methods delegate to the corresponding game\n\t`__state__` methods. The `haps` provided must be in the form `{die1: 4, die2: 2}`. If no `haps`\n\tare given, they are resolved randonmly (using `randomHaps()`).\n\t*/\n\tnext: function next(haps) {\n\t\treturn this.state.next(this.moves, haps || this.randomHaps(), this.update);\n\t},\n\n\t/** Method `randomHaps` calculates a random set of haps.\n\t*/\n\trandomHaps: function randomHaps(random) {\n\t\treturn iterable(this.haps).mapApply(function (n, h) {\n\t\t\treturn [n, h.randomValue(random)];\n\t\t}).toObject();\n\t},\n\n\t/** A `randomNext` picks one of the next states at random.\n\t*/\n\trandomNext: function randomNext(random) {\n\t\treturn this.next(this.randomHaps(random));\n\t},\n\n\t/** The method `possibleHaps` is analogous to `Game.possibleMoves`. It calculates all possible\n\tcombinations of haps.\n\t*/\n\tpossibleHaps: function possibleHaps() {\n\t\treturn Iterable.product.apply(Iterable,\n\t\t\titerable(this.haps).mapApply(function (n, hap) {\n\t\t\t\treturn hap.distribution().mapApply(function (v, p) {\n\t\t\t\t\treturn [n, v, p];\n\t\t\t\t});\n\t\t\t}).toArray()\n\t\t).map(function (haps) {\n\t\t\tvar prob = 1;\n\t\t\treturn [iterable(haps).mapApply(function (n, v, p) {\n\t\t\t\tprob *= p;\n\t\t\t\treturn [n, v];\n\t\t\t}).toObject(), prob];\n\t\t}).toArray();\n\t},\n\n\t/** The `expectedEvaluation` method explores al possible resulting game states from this\n\tcontingent state and applies an evaluation function. This state evaluation function must have\n\tthe signature `stateEvaluation(game, player)`. Asynchronous evaluations are supported, in which\n\tcase a `Future` will be returned.\n\n\tBy default the aggregated result is the sum of the evaluations weighted by the probability of\n\teach possible resulting game state. The `aggregation` function may be specified to override this\n\tbehaviour and process the results in another way. If given, it will be called with an array of\n\ttriples `[haps, probability, evaluation]`.\n\t*/\n\texpectedEvaluation: function expectedEvaluation(player, stateEvaluation, aggregation) {\n\t\tvar game = this,\n\t\t\tisAsync = false,\n\t\t\tpossible = this.possibleHaps().map(function (args) {\n\t\t\t\tvar game2 = game.next(args[0]),\n\t\t\t\t\tev = !game2.isContingent ? stateEvaluation(game2, player) :\n\t\t\t\t\t\tgame2.expectedEvaluation(player, stateEvaluation, aggregation);\n\t\t\t\tisAsync = isAsync || Future.__isFuture__(ev);\n\t\t\t\treturn Future.then(ev, function (ev) {\n\t\t\t\t\targs.push(ev);\n\t\t\t\t\treturn args;\n\t\t\t\t});\n\t\t\t});\n\t\treturn Future.then(isAsync ? Future.all(possible) : possible, aggregation || function (possible) {\n\t\t\tvar r = 0;\n\t\t\tpossible.forEach(function (triple) {\n\t\t\t\tr += triple[1] * triple[2];\n\t\t\t});\n\t\t\treturn r;\n\t\t});\n\t},\n\n\t// ## Utilities ################################################################################\n\n\ttoString: function toString() {\n\t\treturn Sermat.ser(this);\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Contingent',\n\t\tserializer: function serialize_Contingent(obj) {\n\t\t\treturn [obj.state, obj.moves, obj.haps];\n\t\t}\n\t}\n});\n","/** # Tournament\n\nA tournament is a set of matches played between many players. The whole contest\nranks the participants according to the result of the matches. This is an\nabstract base class for many different types of contests.\n*/\nvar Tournament = exports.Tournament = declare({\n\tconstructor: function Tournament(game, players) {\n\t\t/** The tournament always has one [`game`](Game.html) state from which\n\t\tall matches start.\n\t\t*/\n\t\tthis.game = game;\n\t\t/** All the [`players`](Player.html) involved in the tournament must be\n\t\tprovided to the constructor in an array.\n\t\t*/\n\t\tthis.players = Array.isArray(players) ? players : iterables.iterable(players).toArray();\n\t\tthis.statistics = new Statistics();\n\t\tthis.events = new Events({\n\t\t\tevents: ['begin', 'beforeMatch', 'afterMatch', 'end']\n\t\t});\n\t},\n\n\t/** The next match to be played is determined by `__advance__`, which\n\treturns a match instance, or null if the tournament has finished. It is not\n\timplemented in this base class.\n\t*/\n\t__advance__: unimplemented(\"Tournament\", \"__advance__\"),\n\n\t/** `Tournament.run()` plays all the tournament's matches. Since running a\n\tmatch is asynchronous, running a tournament is too. Hence the result is\n\talways a future, which will be resolved when all matches have been played.\n\t*/\n\trun: function run() {\n\t\tthis.onBegin();\n\t\tvar tournament = this;\n\t\treturn Future.doWhile(function () {\n\t\t\treturn Future.then(tournament.__advance__(), function (match) {\n\t\t\t\tif (match) {\n\t\t\t\t\ttournament.beforeMatch(match);\n\t\t\t\t\treturn tournament.__runMatch__(match).then(function (match) {\n\t\t\t\t\t\ttournament.account(match);\n\t\t\t\t\t\ttournament.afterMatch(match);\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t});\n\t\t}).then(this.onEnd.bind(this));\n\t},\n\n\t/** The method `__runMatch__` runs a match. It is present so it can be\n\toverridden, to implement some specific behaviour of the contest.\n\t*/\n\t__runMatch__: function __runMatch__(match) {\n\t\treturn match.run();\n\t},\n\n\t/** Tournaments gather information from the played matches using their\n\t`statistics` property (instance of `creatartis-base.Statistics`). The method\n\t`Tournament.account(match)` is called to accounts the results of each\n\tfinished match for the players' score.\n\n\tThe match results are gathered in the `results` key. The keys `victories`,\n\t`defeats` and `draws` count each result type. The length of each game is\n\trecorded under `length`. The move count at each ply is aggregated under\n\t`width`. All these numbers are open by game, role, player.\n\t*/\n\taccount: function account(match) {\n\t\tvar game = this.game,\n\t\t\tresults = match.result(),\n\t\t\tisDraw = false,\n\t\t\tstats = this.statistics;\n\t\traiseIf(!results, \"Match doesn't have results. Has it finished?\");\n\t\titerable(match.players).forEach(function (p) { // Player statistics.\n\t\t\tvar role = p[0],\n\t\t\t\tplayer = p[1],\n\t\t\t\tplayerResult = results[p[0]];\n\t\t\tstats.add({key:'results', game:game.name, role:role, player:player.name},\n\t\t\t\tplayerResult);\n\t\t\tstats.add({key:(playerResult > 0 ? 'victories' : playerResult < 0 ? 'defeats' : 'draws'),\n\t\t\t\tgame:game.name, role:role, player:player.name}, playerResult);\n\t\t\tstats.add({key:'length', game:game.name, role:role, player:player.name},\n\t\t\t\tmatch.ply()); //FIXME This may not be accurate if the game has random variables.\n\t\t\tmatch.history.forEach(function (entry) {\n\t\t\t\tvar game = entry.state;\n\t\t\t\tif (typeof game === 'function') {\n\t\t\t\t\tvar moves = game.moves();\n\t\t\t\t\tif (moves && moves.hasOwnProperty(role) && moves[role].length > 0) {\n\t\t\t\t\t\tstats.add({ key: 'width', game: game.name, role: role, \n\t\t\t\t\t\t\tplayer: player.name }, moves[role].length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/** ## Events #############################################################\n\n\tTournaments provide events to enable further analysis and control over it.\n\t`Tournament.events` is the event handler. The emitted events are:\n\t*/\n\n\t/** + The `begin` event fired by `Tournament.onBegin()` when the whole\n\tcontest begins. The callbacks should have the signature\n\t`function (tournament)`.\n\t*/\n\tonBegin: function onBegin() {\n\t\tthis.events.emit('begin', this);\n\t\tif (this.logger) {\n\t\t\tthis.logger.info('Tournament begins for game ', game.name, '.');\n\t\t}\n\t},\n\n\t/** + The `beforeMatch` event triggered by `Tournament.beforeMatch(match)`\n\tjust before starting a match. The callbacks should have the signature\n\t`function (match, tournament)`.\n\t*/\n\tbeforeMatch: function beforeMatch(match) {\n\t\tthis.events.emit('beforeMatch', match, this);\n\t\tif (this.logger) {\n\t\t\tthis.logger.debug('Beginning match with ', JSON.stringify(match.players), '.');\n\t\t}\n\t},\n\n\t/** + The `afterMatch` event triggered by `Tournament.afterMatch(match)`\n\tjust after a match ends. The callbacks should have the signature\n\t`function (match, tournament)`.\n\t*/\n\tafterMatch: function afterMatch(match) {\n\t\tthis.events.emit('afterMatch', match, this);\n\t\tif (this.logger) {\n\t\t\tthis.logger.debug('Finishing match with ', JSON.stringify(match.players), '.');\n\t\t}\n\t},\n\n\t/** + The `end` event triggered by `Tournament.onEnd()` when the whole\n\tcontest is completed. The callbacks should have the signature\n\t`function (statistics, tournament)`.\n\t*/\n\tonEnd: function onEnd() {\n\t\tthis.events.emit('end', this.statistics, this);\n\t\tif (this.logger) {\n\t\t\tthis.logger.info('Tournament ends for game ', game.name, ':\\n', this.statistics, '\\n');\n\t\t}\n\t},\n\n\t// ## Utilities ################################################################################\n\n\ttoString: function toString() {\n\t\treturn Sermat.ser(this);\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Tournament',\n\t\tserializer: function serialize_Tournament(obj) {\n\t\t\treturn [obj.game, obj.players];\n\t\t}\n\t}\n}); // declare Tournament\n","/** # Checkerboard\n\nBase class for checkerboards representations based on several different data structures.\n*/\nvar Checkerboard = utils.Checkerboard = declare({\n\t/** The base constructor only sets the board dimensions: `height` and `width`.\n\t*/\n\tconstructor: function Checkerboard(height, width) {\n\t\tif (!isNaN(height)) {\n\t\t\tthis.height = height|0;\n\t\t}\n\t\tif (!isNaN(width)) {\n\t\t\tthis.width = width|0;\n\t\t}\n\t},\n\t\n\t/** The value for empty squares is `emptySquare`. This will be used in functions walking and \n\ttraversing the board. \n\t*/\n\temptySquare: null,\n\t\n\t// ## Board information ########################################################################\n\t\n\t/** All coordinates are represented by `[row, column]` arrays. To check if a coordinate is \n\tinside the board, use `isValidCoord(coord)`.\n\t*/\n\tisValidCoord: function isValidCoord(coord) {\n\t\treturn Array.isArray(coord) && !isNaN(coord[0]) && !isNaN(coord[1])\t&& \n\t\t\tcoord[0] >= 0 && coord[0] < this.height && \n\t\t\tcoord[1] >= 0 && coord[1] < this.width;\n\t},\n\t\n\t/** Method `coordinates()` returns the sequence of the board's valid positions; first by row \n\tthen by column.\n\t*/\n\tcoordinates: function coordinates() {\n\t\treturn Iterable.range(this.height).product(Iterable.range(this.width));\n\t},\n\t\n\t/** Method `square(coord, outside)` should get the contents at a given coordinate. If the \n\tcoordinate is off the board, `outside` must be returned. This method is abstract so it must be \n\toverriden in subclasses.\n\t*/\n\tsquare: unimplemented('utils.Checkerboard', 'square'),\n\t\n\t/** A square is assumed to be empty when its value is equal to `emptySquare`.\n\t*/\n\tisEmptySquare: function isEmptySquare(coord) {\n\t\treturn this.square(coord) === this.emptySquare;\n\t},\n\t\n\t// ### Lines ###################################################################################\n\t\n\t/** Many games must deal with line configurations of pieces. The following methods help with \n\tthis kind of logic. Each line is a sequence of coordinates in the board.\n\t\n\t+ `horizontals()`: All the horizontal lines (rows).\n\t*/\n\thorizontals: function horizontals() {\n\t\tvar width = this.width;\n\t\treturn Iterable.range(this.height).map(function (row) {\n\t\t\treturn Iterable.range(width).map(function (column) {\n\t\t\t\treturn [row, column];\n\t\t\t});\n\t\t});\n\t},\n\t\n\t/** \n\t+ `verticals()`: All the vertical lines (columns).\n\t*/\n\tverticals: function verticals() {\n\t\tvar height = this.height;\n\t\treturn Iterable.range(this.width).map(function (column) {\n\t\t\treturn Iterable.range(height).map(function (row) {\n\t\t\t\treturn [row, column];\n\t\t\t});\n\t\t});\n\t},\n\t\n\t/** \n\t+ `orthogonals()`: All the horizontal (rows) and vertical lines (columns) in the board.\n\t*/\n\torthogonals: function orthogonals() {\n\t\treturn this.horizontals().chain(this.verticals());\n\t},\n\t\n\t/**\n\t+ `positiveDiagonals()`: All the positive diagonals lines (those where row = k + column).\n\t*/\n\tpositiveDiagonals: function positiveDiagonals() {\n\t\tvar width = this.width, \n\t\t\theight = this.height, \n\t\t\tcount = height + width - 1;\n\t\treturn Iterable.range(count).map(function (i) {\n\t\t\tvar row = Math.max(0, height - i - 1),\n\t\t\t\tcolumn = Math.max(0, i - height + 1);\n\t\t\treturn Iterable.range(Math.min(i + 1, count - i)).map(function (j) {\n\t\t\t\treturn [row + j, column + j];\n\t\t\t});\n\t\t});\n\t},\n\t\n\t/** \n\t+ `negativeDiagonals()`: All the negative diagonals lines (those where row = k - column).\n\t*/\n\tnegativeDiagonals: function negativeDiagonals() {\n\t\tvar width = this.width, \n\t\t\theight = this.height, \n\t\t\tcount = height + width - 1;\n\t\treturn Iterable.range(count).map(function (i) {\n\t\t\tvar row = Math.min(i, height - 1),\n\t\t\t\tcolumn = Math.max(0, i - height + 1);\n\t\t\treturn Iterable.range(Math.min(i + 1, count - i)).map(function (j) {\n\t\t\t\treturn [row - j, column + j];\n\t\t\t});\n\t\t});\n\t},\n\t\n\t/**\n\t+ `diagonals()`: All the diagonal lines in the board.\n\t*/\n\tdiagonals: function diagonals() {\n\t\treturn this.positiveDiagonals().chain(this.negativeDiagonals());\n\t},\n\t\n\t/**\n\t+ `lines()`: All the horizontal, vertical and diagonal lines in the board.\n\t*/\n\tlines: function lines() {\n\t\treturn this.orthogonals().chain(this.diagonals());\n\t},\n\t\n\t/** The previous methods return the whole lines. Some times the game logic demands checking \n\tlines of a certain length. These are sublines, and can be calculated by \n\t`sublines(lines, length)`. It obviously filters lines which are shorter than length.\n\t*/\n\tsublines: function sublines(lines, length) {\n\t\treturn iterable(lines).map(function (line) {\n\t\t\treturn Array.isArray(line) ? line : iterable(line).toArray();\n\t\t}, function (line) {\n\t\t\treturn line.length >= length;\n\t\t}).map(function (line) {\n\t\t\treturn Iterable.range(0, line.length - length + 1).map(function (i) {\n\t\t\t\treturn line.slice(i, i + length);\n\t\t\t});\n\t\t}).flatten();\n\t},\n\t\n\t// ### Walks ###################################################################################\n\t\n\t/** A walk is a sequence of coordinates in the board that start at a given point and advances in\n\ta certain direction. The `walk(coord, delta)` method returns an iterable with coordinates from \n\t`coord` and on, adding `delta`'s row and column until going off the board.\n\t*/\n\twalk: function walk(coord, delta) {\n\t\tvar board = this;\n\t\treturn new Iterable(function __iter__() {\n\t\t\tvar current = coord.slice();\n\t\t\treturn function __walkIterator__() {\n\t\t\t\tif (board.isValidCoord(current)) {\n\t\t\t\t\tvar result = current.slice();\n\t\t\t\t\tcurrent[0] += delta[0];\n\t\t\t\t\tcurrent[1] += delta[1];\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Iterable.STOP_ITERATION;\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t},\n\t\n\t/** Convenient method `walks(coord, deltas)` can be used to get many walks from the same origin.\n\t*/\n\twalks: function walks(coord, deltas) {\n\t\tvar board = this;\n\t\treturn deltas.map(function (delta) {\n\t\t\treturn board.walk(coord, delta);\n\t\t});\n\t},\n\t\n\t/** Frequently used deltas for walks are available at `DIRECTIONS`.\n\t*/\n\t\"static DIRECTIONS\": {\n\t\tHORIZONTAL: [[0,-1], [0,+1]],\n\t\tVERTICAL:   [[-1,0], [+1,0]], \n\t\tORTHOGONAL: [[0,-1], [0,+1], [-1,0], [+1,0]],\n\t\tDIAGONAL:   [[-1,-1], [-1,+1], [+1,-1], [+1,+1]],\n\t\tEVERY:      [[0,-1], [0,+1], [-1,0], [+1,0], [-1,-1], [-1,+1], [+1,-1], [+1,+1]]\n\t},\n\t\n\t// ## Board modification #######################################################################\n\t\n\t/** Game states must not be modifiable, else game search algorithms may fail or be extremely \n\tcomplicated. Then, all board altering method in `Checkerboard` must return a new board instance \n\tand leave this instance unspoiled.\n\t\n\tMost board modification functions have two versions: one which actually modifies the board state\n\tand another which returns a modified copy. This is meant to optimize chains of board \n\talterations. To get a copy of this board, the `clone` method can be used.\n\t*/\n\tclone: unimplemented('utils.Checkerboard', 'clone'),\n\t\n\t/** The first function to change the board is `place(coord, value)`. It places the value at the \n\tgiven coordinate, replacing whatever was there.\n\t\n\tThe `__place__` version modifies this board, and is not implemented in the base class. It should\n\treturn this instance, to enable chaining.\n\t*/\n\t__place__: unimplemented('utils.Checkerboard', 'place'),\n\t\n\tplace: function place(coord, value) {\n\t\treturn this.clone().__place__(coord, value);\n\t},\n\n\t/** Another usual operation is `move(coordFrom, coordTo, valueLeft)`. It moves the contents at \n\t`coordFrom` to `coordTo`. Whatever is at `coordTo` gets replaced, and `valueLeft` is placed at\n\t`coordFrom`. If `valueLeft` is undefined, `emptySquare` is used.\n\t*/\n\t__move__: function __move__(coordFrom, coordTo, valueLeft) {\n\t\treturn this.__place__(coordTo, this.square(coordFrom))\n\t\t\t.__place__(coordFrom, typeof valueLeft === 'undefined' ? this.emptySquare : valueLeft);\n\t},\n\t\n\tmove: function move(coordFrom, coordTo, valueLeft) {\n\t\treturn this.clone().__move__(coordFrom, coordTo, valueLeft);\n\t},\n\t\n\t/** The next board operation is `swap(coordFrom, coordTo)`, which moves the contents at \n\t`coordFrom` to `coordTo`, and viceversa.\n\t*/\n\t__swap__: function __swap__(coordFrom, coordTo) {\n\t\tvar valueTo = this.square(coordTo);\n\t\treturn this.__place__(coordTo, this.square(coordFrom))\n\t\t\t.__place__(coordFrom, valueTo);\n\t},\n\t\n\tswap: function swap(coordFrom, coordTo) {\n\t\treturn this.clone().__swap__(coordFrom, coordTo);\n\t},\n\t\n\t// ## Whole board operations ###################################################################\n\t\n\t/** The `transform` builds a new board mapping coordinates of this board with the given\n\tfunction.\n\t*/\n\ttransform: function transform(coordinateMapping) {\n\t\tvar result = this.clone(),\n\t\t\tboard = this;\n\t\tthis.coordinates().forEach(function (position) {\n\t\t\tvar newPosition = coordinateMapping.apply(board, [board, position].concat(position));\n\t\t\tresult.__place__(newPosition, board.square(position));\n\t\t});\n\t\treturn result;\n\t},\n\t\n\t/** Symmetries transform the whole board at once. The `horizontalSymmetry` of the board flips it \n\twith a vertical axis at its center, while the `verticalSymmetry` flips it with an horizontal \n\taxis.\n\t*/\n\thorizontalSymmetry: function horizontalSymmetry() {\n\t\treturn this.transform(function (board, position, row, column) {\n\t\t\treturn [row, board.width - column - 1];\n\t\t});\n\t},\n\t\n\tverticalSymmetry: function verticalSymmetry() {\n\t\treturn this.transform(function (board, position, row, column) {\n\t\t\treturn [board.height - row - 1, column];\n\t\t});\n\t},\n\t\n\t/** Rotations also transform the whole board at once. The `clockwiseRotation` of the board \n\trotates in the direction that the hands of a clock, while the `counterClockwiseRotation` rotates\n\tit in the opposite direction.\n\t*/\n\tclockwiseRotation: function clockwiseRotation() {\n\t\treturn this.transform(function (board, position, row, column) {\n\t\t\treturn [column, board.height - row - 1];\n\t\t});\n\t},\n\t\n\tcounterClockwiseRotation: function counterClockwiseRotation() {\n\t\treturn this.transform(function (board, position, row, column) {\n\t\t\treturn [board.width - column - 1, row];\n\t\t});\n\t},\n\t\n\t// ## Board presentation. ######################################################################\n\t\n\t/** Board games' user interfaces may be implemented using HTML & CSS. This is the case of \n\tLudorum's playtesters.\n\t*/\n\trenderAsHTMLTable: function (document, container, callback) {\n\t\tvar board = this, // for closures.\n\t\t\ttable = document.createElement('table');\n\t\tcontainer.appendChild(table);\n\t\tboard.horizontals().reverse().forEach(function (line) {\n\t\t\tvar tr = document.createElement('tr');\n\t\t\ttable.appendChild(tr);\n\t\t\tline.forEach(function (coord) {\n\t\t\t\tvar square = board.square(coord),\n\t\t\t\t\ttd = document.createElement('td'),\n\t\t\t\t\tdata = {\n\t\t\t\t\t\tid: \"ludorum-square-\"+ coord.join('-'),\n\t\t\t\t\t\tclassName: \"ludorum-square\",\n\t\t\t\t\t\tsquare: square,\n\t\t\t\t\t\tcoord: coord,\n\t\t\t\t\t\tinnerHTML: base.Text.escapeXML(square)\n\t\t\t\t\t};\n\t\t\t\tif (callback) {\n\t\t\t\t\tdata = callback(data) || data;\n\t\t\t\t}\n\t\t\t\ttd['ludorum-data'] = data;\n\t\t\t\ttd.id = data.id;\n\t\t\t\ttd.className = data.className;\n\t\t\t\ttd.innerHTML = data.innerHTML;\n\t\t\t\tif (data.onclick) {\n\t\t\t\t\ttd.onclick = data.onclick;\n\t\t\t\t}\n\t\t\t\ttr.appendChild(td);\n\t\t\t});\n\t\t});\n\t\treturn table;\n\t},\n\t\n\t// ## Heuristics ###############################################################################\n\t\n\t/** A `weightedSum` is an simple way of defining an heuristic. Every position in the board is \n\tassigned a weight, and every possible value is assigned a coefficients (usually player is 1, \n\topponent is -1, else is 0).\n\t\n\tWeights have to be in the same order that `coordinates()` enumerates the board's positions. This\n\tfunction assumes the weights are normalized and sufficient to cover the whole board.\n\t*/\n\tweightedSum: function weightedSum(weights, coefficients) {\n\t\tvar board = this;\n\t\treturn this.coordinates().zip(weights).mapApply(function (coord, weight) {\n\t\t\treturn coefficients[board.square(coord)] * weight || 0;\n\t\t}).sum();\n\t}\n}); //// declare utils.Checkerboard.\n","/** # CheckerboardFromString\n\n[`Checkerboard`](Checkerboard.html) implementation represented by a simple string (one character per \nsquare).\n*/\nvar CheckerboardFromString = utils.CheckerboardFromString = declare(Checkerboard, {\n\t/** The constructor takes `height`, `width`, the whole board content in a `string`, and \n\toptionally the empty square character.\n\t*/\n\tconstructor: function CheckerboardFromString(height, width, string, emptySquare) {\n\t\tCheckerboard.call(this, height, width);\n\t\tif (emptySquare && emptySquare !== this.emptySquare) {\n\t\t\tthis.emptySquare = (emptySquare +'').charAt(0);\n\t\t}\n\t\tif (string && string.length !== height * width) {\n\t\t\tthrow new Error('Given string '+ JSON.stringify(string) +' does not match board dimensions.');\n\t\t}\n\t\tthis.string = string || this.emptySquare.repeat(height * width);\n\t},\n\t\n\t/** The `emptySquare` in `CheckerboardFromString` is `'.'` by default.\n\t*/\n\temptySquare: '.',\t\n\t\n\t/** The default string conversion of `CheckerboardFromString` prints the board one line by row, \n\tlast row on top.\n\t*/\n\ttoString: function toString() {\n\t\tvar string = this.string, height = this.height, width = this.width;\n\t\treturn Iterable.range(height).map(function (i) {\n\t\t\treturn string.substr((height - i - 1) * width, width);\n\t\t}).join('\\n');\n\t},\n\t\n\t// ## Board information ########################################################################\n\t\n\t/** The `square(coord, outside)` return the character at `(row * width + column)` if the \n\tcoordinate is inside the board. Else returns `outside`.\n\t*/\n\tsquare: function square(coord, outside) {\n\t\tvar row = coord[0], \n\t\t\tcolumn = coord[1],\n\t\t\twidth = this.width;\n\t\tif (row >= 0 && row < this.height && column >= 0 && column < width) {\n\t\t\treturn this.string.charAt(row * width + column);\n\t\t} else {\n\t\t\treturn outside;\n\t\t}\n\t},\n\t\n\t// ### Lines ###################################################################################\n\t\n\t/** Since square contents in `CheckerboardFromString` are just characters, lines can be thought \n\tas strings. The method `asString(line)` takes an iterable of coordinates and returns a string of \n\tthe characters found at each point in the sequence.\n\t*/\n\tasString: function asString(line) {\n\t\tvar board = this;\n\t\treturn line.map(function (coord) {\n\t\t\treturn board.square(coord);\n\t\t}).join('');\n\t},\n\t\n\t/** The method `asStrings(lines)` can be used to easily map `asString(line)` to a sequence of \n\tlines, like the one calculated by `lines()`.\n\t*/\n\tasStrings: function asStrings(lines) {\n\t\tvar board = this;\n\t\treturn lines.map(function (line) {\n\t\t\treturn board.asString(line);\n\t\t});\n\t},\n\t\n\t/** Many games based on board configurations (like connection games) have patterns that can be \n\texpressed with regular expressions. The method `asRegExp(line, insideLine, outsideLine)` takes a \n\tline (iterable of coordinates) and returns a string with a regular expression. This may be used \n\tto tests the whole board string for the line.\n\t\n\t_Warning!_ Both `insideLine` and `outsideLine` must be simple regular expressions (e.g. a \n\tcharacter or atom). If more complex expressions are required they must be provided between \n\tparenthesis.\n\t*/\n\tasRegExp: function asRegExp(line, insideLine, outsideLine) {\n\t\toutsideLine = outsideLine || '.';\n\t\tvar width = this.width,\n\t\t\tsquares = Iterable.repeat(false, width * this.height).toArray();\n\t\tline.forEach(function (coord) {\n\t\t\tsquares[coord[0] * width + coord[1]] = true;\n\t\t});\n\t\tvar result = '', count = 0, current;\n\t\tfor (var i = 0; i < squares.length; count = 0) {\n\t\t\tcurrent = squares[i];\n\t\t\tdo {\n\t\t\t\t++count;\n\t\t\t} while (++i < squares.length && squares[i] === current);\n\t\t\tif (count < 2) {\n\t\t\t\tresult += current ? insideLine : outsideLine;\n\t\t\t} else {\n\t\t\t\tresult += (current ? insideLine : outsideLine) +'{'+ count +'}';\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\t\n\t/** The method `asRegExps(lines)` can be used to easily map `asRegExp(line)` to a sequence of \n\tlines. All regular expressions are joined as a union (`|`). Use with caution, because the whole \n\tregular expression can get very big even with small boards.\n\t*/\n\tasRegExps: function asRegExps(lines, insideLine, outsideLine) {\n\t\tvar board = this;\n\t\treturn lines.map(function (line) {\n\t\t\treturn board.asRegExp(line, insideLine, outsideLine);\n\t\t}).join('|');\n\t},\n\t\n\t// ## Board modification #######################################################################\n\t\n\t/** Cloning a CheckerboardFromString simply calls the constructor again with the proper \n\targuments to replicate this instance.\n\t*/\n\tclone: function clone() {\n\t\treturn new this.constructor(this.height, this.width, this.string, \n\t\t\tthis.hasOwnProperty('emptySquare') ? this.emptySquare : undefined);\n\t},\n\t\n\t/** A `place(coord, value)` means only changing one character in the underlying string. The \n\t`value` must be a character, and `coord` a point inside the board.\n\t*/\n\t__place__: function __place__(coord, value) {\n\t\traiseIf(!this.isValidCoord(coord), \"Invalid coordinate \", coord, \".\");\n\t\tvalue = (value + this.emptySquare).charAt(0);\n\t\tvar i = coord[0] * this.width + coord[1];\n\t\tthis.string = this.string.substr(0, i) + value + this.string.substr(i + 1);\n\t\treturn this;\n\t},\n\t\n\t// ## Utilities ################################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'CheckerboardFromString',\n\t\tserializer: function serialize_CheckerboardFromString(obj) {\n\t\t\tvar r = [obj.height, obj.width, obj.string];\n\t\t\tif (obj.hasOwnProperty('emptySquare')) {\n\t\t\t\tr.push(obj.emptySquare);\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t}\n}); // declare utils.CheckerboardFromString","/** # Checkerboard from pieces\n\n[`Checkerboard`](Checkerboard.html) implementation represented by a list of pieces (objects) with a\nlocation in the board.\n*/\nvar CheckerboardFromPieces = utils.CheckerboardFromPieces = declare(Checkerboard, {\n\t/** The constructor takes `height`, `width`, a list of piece objects and optionally the empty \n\tsquare object. The piece objects must have a property `position`. Only one piece is allowed at\n\teach square.\n\t*/\n\tconstructor: function CheckerboardFromPieces(height, width, pieces, emptySquare) {\n\t\tCheckerboard.call(this, height, width);\n\t\tvar board = this;\n\t\tif (emptySquare !== this.emptySquare) {\n\t\t\tthis.emptySquare = emptySquare;\n\t\t}\n\t\tif (Array.isArray(pieces)) {\n\t\t\tthis.pieces = {}; \n\t\t\titerable(pieces || []).forEach(function (piece) {\n\t\t\t\traiseIf(!Array.isArray(piece.position), \"Piece has not a position (\", piece, \")!\");\n\t\t\t\tboard.pieces[piece.position +''] = piece;\n\t\t\t});\n\t\t} else if (typeof pieces === 'object') {\n\t\t\tthis.pieces = base.copy({}, pieces);\n\t\t} else {\n\t\t\traise(\"Invalid pieces definition: \", pieces, \"!\");\n\t\t}\n\t},\n\t\n\t/** The `emptySquare` in `CheckerboardFromPieces` is `null` by default.\n\t*/\n\temptySquare: null,\t\n\t\n\t/** The default string conversion of `CheckerboardFromPieces` prints the piece list.\n\t*/\n\ttoString: function toString() {\n\t\treturn '['+ iterable(this.pieces).select(1).join(', ') +']';\n\t},\n\t\n\t// ## Board information ########################################################################\n\t\n\t/** The `square(coord, outside)` return the piece object at the given `coord` if there is one \n\tand the coordinate is inside the board. Else returns `outside`.\n\t*/\n\tsquare: function square(coord, outside) {\n\t\treturn this.pieces[coord] || outside;\n\t},\n\t\n\t// ## Board modification #######################################################################\n\t\n\t/** Cloning a `CheckerboardFromPieces` simply calls the constructor again with the proper \n\targuments to replicate this instance. The `pieces` object is copied _shallowly_ by the \n\tconstructor.\n\t*/\n\tclone: function clone() {\n\t\treturn new this.constructor(this.height, this.width, this.pieces, this.emptySquare);\n\t},\n\t\n\t/** A `place(coord, value)` means removing any existing piece at the given `coord` and adding \n\tthe `value` piece if given.\n\t*/\n\t__place__: function __place__(coord, value) {\n\t\traiseIf(!this.isValidCoord(coord), \"Invalid coordinate \", coord, \"!\");\n\t\tvar id = coord +'';\n\t\tdelete this.pieces[id];\n\t\tif (value) {\n\t\t\tthis.pieces[id] = value;\n\t\t}\n\t\treturn this;\n\t},\n\t\n\t// ## Utilities ################################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'CheckerboardFromPieces',\n\t\tserializer: function serialize_CheckerboardFromPieces(obj) {\n\t\t\tvar r = [obj.height, obj.width, obj.pieces];\n\t\t\tif (obj.hasOwnProperty('emptySquare')) {\n\t\t\t\tr.push(obj.emptySquare);\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t}\n}); // declare utils.CheckerboardFromPieces\n","/** # Scanner\n\nComponent for scanning a game's tree.\n*/\nexports.utils.Scanner = declare({\n\t/** A Scanner builds a sample of a game tree, in order to get statistics from some of all\n\tpossible matches. The given `config` must have:\n\t*/\n\tconstructor: function Scanner(config) {\n\t\tinitialize(this, config)\n\t\t// + `game`: Game to scan.\n\t\t\t.object('game', { ignore: true })\n\t\t// + `maxWidth=1000`: Maximum amount of game states held at each step.\n\t\t\t.integer('maxWidth', { defaultValue: 1000, coerce: true })\n\t\t// + `maxLength=50`: Maximum length of simulated matches.\n\t\t\t.integer('maxLength', { defaultValue: 50, coerce: true })\n\t\t// + `random=randomness.DEFAULT`: Pseudorandom number generator to use in the simulations.\n\t\t\t.object('random', { defaultValue: Randomness.DEFAULT })\n\t\t// + `statistics=<new>`: Component to gather relevant statistics.\n\t\t\t.object('statistics', { defaultValue: new Statistics() })\n\t\t// + `adjustWidth`: Reduce the width of the scan window for every final state found.\n\t\t\t.bool('adjustWidth', { defaultValue: false, coerce: true });\n\t},\n\t\n\t/** A scan of a game's tree reproduces and samples the set of all possible matches from the\n\tgiven game states. The simulation halts at `maxLength` plies, and never holds more than \n\t`maxWidth` game states. Since this process is asynchronous, this method returns a future.\n\t\n\tThe `players` argument may provide a player for some or all of the games' roles. If available,\n\tthey will be used to decide which move is applied to each game state. If missing, all next game\n\tstates will be added. Ergo no players means a simulation off all possible matches.\t\t\n\t*/\n\tscan: function scan(players) {\n\t\tvar scanner = this,\n\t\t\twindow = arguments.length < 2 ? \n\t\t\t\t(this.game ? [this.game] : []) : \n\t\t\t\tArray.prototype.slice.call(arguments, 1),\n\t\t\tply = 0;\n\t\tthis.__currentWidth__ = this.maxLength;\n\t\treturn Future.whileDo(function () {\n\t\t\treturn window.length > 0 && ply < scanner.__currentWidth__;\n\t\t}, function () {\n\t\t\treturn Future.all(window.map(function (game) {\n\t\t\t\treturn scanner.__advance__(players, game, ply);\n\t\t\t})).then(function (level) {\n\t\t\t\twindow = iterable(level).filter(function (nexts) {\n\t\t\t\t\t\tvar isEmpty = nexts.isEmpty();\n\t\t\t\t\t\tif (isEmpty && scanner.adjustWidth) {\n\t\t\t\t\t\t\tscanner.__currentWidth__--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn !isEmpty;\n\t\t\t\t\t})\n\t\t\t\t\t.flatten()\n\t\t\t\t\t.sample(scanner.__currentWidth__, scanner.random)\n\t\t\t\t\t.toArray();\n\t\t\t\treturn ++ply;\n\t\t\t});\n\t\t}).then(function () {\n\t\t\tscanner.statistics.add({ key:'aborted' }, window.length);\n\t\t\treturn scanner.statistics;\n\t\t});\n\t},\n\t\n\t/** Performs scans for many different player setups.\n\t*/\n\tscans: function scans() {\n\t\treturn Future.sequence(Array.prototype.slice.call(arguments), this.scan.bind(this));\n\t},\n\t\n\t/** The `__advance__` method advances the given game by one ply. This may mean for non final\n\tgame states either instantiate random variables, ask the available player for a decision, or \n\ttake all next game states. Final game states are removed. \n\t\n\tAll game states are accounted in the scanner's statistics. The result is an iterable with the \n\tgame states to add to the next scan window.\n\t*/\n\t__advance__: function __advance__(players, game, ply) {\n\t\tif (game.isContingent) {\n\t\t\treturn iterable(game.possibleHaps()).mapApply(function (haps, prob) {\n\t\t\t\treturn game.next(haps);\n\t\t\t});\n\t\t} else if (this.account(players, game, ply)) {\n\t\t\treturn Iterable.EMPTY;\n\t\t} else {\n\t\t\tvar moves = game.moves(),\n\t\t\t\tstats = this.statistics;\n\t\t\treturn Future.all(game.activePlayers.map(function (role) {\n\t\t\t\tif (players && players[role]) {\n\t\t\t\t\tvar p = players[role],\n\t\t\t\t\t\tdecisionTime = stats.stat({ key:'decision.time', game: game.name, \n\t\t\t\t\t\t\trole: role, player: p.name });\n\t\t\t\t\tdecisionTime.startTime();\n\t\t\t\t\treturn Future.when(p.decision(game, role)).then(function (move) {\n\t\t\t\t\t\tdecisionTime.addTime();\n\t\t\t\t\t\treturn [[role, move]];\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn moves[role].map(function (move) {\n\t\t\t\t\t\treturn [role, move];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})).then(function (decisions) {\n\t\t\t\treturn Iterable.product.apply(Iterable, decisions).map(function (moves) {\n\t\t\t\t\treturn game.next(iterable(moves).toObject());\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t},\n\t\t\t\n\t/** The `account` method gathers statistics about the game. These include:\n\t\t\n\t+ `game.result`: Final game state results. Also available for victory and defeat.\n\t+ `game.length`: Match length in plies. Also available for victory and defeat.\n\t+ `game.width`: Number of available moves.\n\t+ `draw.length`: Drawn match length in plies.\n\t\n\tReturns whether the given game state is final or not.\n\t*/\n\taccount: function account(players, game, ply) {\n\t\tvar result = game.result(),\n\t\t\tstats = this.statistics;\n\t\tif (result) {\n\t\t\titerable(game.players).forEach(function (role) {\n\t\t\t\tvar r = result[role],\n\t\t\t\t\tp = (players && players[role]) ? players[role].name : '';\n\t\t\t\tstats.add({key:'game.result', game:game.name, role:role, player:p}, r, game);\n\t\t\t\tstats.add({key:'game.length', game:game.name, role:role, player:p}, ply, game);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tstats.add({key:'defeat.result', game:game.name, role:role, player:p}, r, game);\n\t\t\t\t\tstats.add({key:'defeat.length', game:game.name, role:role, player:p}, ply, game);\n\t\t\t\t} else if (r > 0) {\n\t\t\t\t\tstats.add({key:'victory.result', game:game.name, role:role, player:p}, r, game);\n\t\t\t\t\tstats.add({key:'victory.length', game:game.name, role:role, player:p}, ply, game);\n\t\t\t\t} else {\n\t\t\t\t\tstats.add({key:'draw.length', game:game.name, role:role, player:p}, ply, game);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else {\n\t\t\tvar moves = game.moves();\n\t\t\titerable(game.activePlayers).forEach(function (role) {\n\t\t\t\tstats.add({key:'game.width', game:game.name, role:role}, moves[role].length);\n\t\t\t});\n\t\t\treturn false;\n\t\t}\n\t},\n\n\t/** Shortcut to scan a game. \n\t*/\n\t'static scan': function scan(config) {\n\t\treturn (new this(config)).scan(config.players);\n\t}\n}); // Scanner.\n","/** # Cache\n\nA game cache contains a part of a game tree, avoiding redundancies. It can be\nused to implement a [transposition table](http://en.wikipedia.org/wiki/Transposition_table) \nor similar data structures.\n*/\nutils.Cache = declare({\n\t/** The `Cache` constructor may take a game to define as `root`.\n\t*/\n\tconstructor: function Cache(game) {\n\t\tthis.clear();\n\t\tif (game) {\n\t\t\tthis.root(game);\n\t\t}\n\t},\n\t\n\t/** The `stateIdentifier(state)` of every game state is used as the key in \n\tthe cache's entries. By default is calculated with the `Game.identifier()`\n\tmethod.\n\t*/\n\tstateIdentifier: function stateIdentifier(state) {\n\t\treturn state.identifier();\n\t},\n\t\n\t/** The `moveIdentifier(move)` is used as the key in each entry's \n\tdescendants. By default it uses the move JSON _stringification_.\n\t*/\n\tmoveIdentifier: function moveIdentifier(move) {\n\t\treturn JSON.stringify(move);\n\t},\n\t\n\t/** The `has(state|id)` returns if the given state or state identifier has \n\tan entry in this cache.\n\t*/\n\thas: function has(state) {\n\t\tvar stateId = typeof state === 'string' ? state : this.stateIdentifier(state);\n\t\treturn this.__entries__.hasOwnProperty(stateId);\n\t},\n\t\n\t/** If the given state or state identifier has en entry in this cache, \n\t`get(state)` returns that entry. Else it returns `undefined`.\n\t*/\n\tget: function get(state) {\n\t\tvar stateId = typeof state === 'string' ? state : this.stateIdentifier(state);\n\t\treturn this.__entries__[stateId];\n\t},\n\t\n\t/** `size()` returns the amount of entries in this cache.\n\t*/\n\tsize: function size() {\n\t\treturn Object.keys(this.__entries__).length;\n\t},\n\t\n\t/** If the given state has no entry in this cache, `entry(state, id)` builds\n\ta new entry, adds it to this cache and returns it. If the state is already\n\tcached, its entry is returned.\n\tEvery entry has the game `state`, its `id`, the states that may come before\n\t(the `precursors`) and the states that may follow (the `descendants`).\n\t*/\n\tentry: function entry(state, id) {\n\t\tid = id || this.stateIdentifier(state);\n\t\tif (this.has(id)) {\n\t\t\treturn this.get(id);\n\t\t} else {\n\t\t\tvar _entry = { id: id, state: state, precursors: [], descendants: {} };\n\t\t\tthis.__entries__[id] = _entry;\n\t\t\treturn _entry;\n\t\t}\n\t},\n\t\n\t/** An entry's `descendant(entry, moves)` is the entry of the game state \n\tfollowing the given entry's game state with the given moves. The method not\n\tonly returns the entry is this state, it creates and caches that entry if \n\tnot present.\n\t*/\n\tdescendant: function descendant(entry, moves) {\n\t\tvar movesId = this.moveIdentifier(moves),\n\t\t\tdescendants = entry.descendants;\n\t\tif (descendants.hasOwnProperty(movesId)) { // Already expanded.\n\t\t\treturn descendants[movesId][1];\n\t\t} else {\n\t\t\tvar nextState = entry.state.next(moves),\n\t\t\t\tnextStateId = this.stateIdentifier(nextState),\n\t\t\t\tnextEntry = this.get(nextStateId) || // Reuse entry in cache if it exists.\n\t\t\t\t\tthis.entry(nextState, nextStateId); // Else add new entry.\n\t\t\tdescendants[movesId] = [moves, nextEntry];\n\t\t\tnextEntry.precursors.push([moves, entry]);\n\t\t\treturn nextEntry;\n\t\t}\n\t},\n\t\n\t/** An entry `descendants(entry)` is an array of all the entry's \n\tdescendants, for all the possible moves for the entry's state.\n\t*/\n\tdescendants: function descendants(entry) {\n\t\tvar descendant = this.descendant.bind(this, entry);\n\t\tif (arguments.length > 1) {\n\t\t\treturn Array.prototype.slice.call(arguments, 1).map(descendant);\n\t\t} else { // if (arguments.length == 0)\n\t\t\treturn entry.state.possibleMoves().map(descendant);\n\t\t}\n\t},\n\t\n\t/** A clear cache has no entries and of course no root.\n\t*/\n\tclear: function clear() {\n\t\tthis.__entries__ = {};\n\t\tthis.__root__ = null;\n\t},\n\t\n\t/** If `root()` is called without arguments, it returns the current root.\n\tIf a state is given, that state is assigned as the new root, and the whole\n\tcache is pruned.\n\t*/\n\troot: function root(state) {\n\t\tif (arguments.length > 0) { // Called with argument means setter.\n\t\t\tvar stateId = this.stateIdentifier(state);\n\t\t\tthis.__root__ = this.get(stateId) || this.entry(state, stateId);\n\t\t\tthis.prune(stateId);\n\t\t}\n\t\treturn this.__root__;\n\t},\n\t\n\t/** `prune(id=root.id)` deletes all nodes except the one with the given id \n\tand its descendants.\n\t*/\n\tprune: function prune(id) {\n\t\tvar pending = [id || this.__root__.id], \n\t\t\tpruned = {},\n\t\t\tentry;\n\t\twhile (id = pending.shift()) {\n\t\t\tif (!pruned.hasOwnProperty(id)) {\n\t\t\t\tentry = this.get(id);\n\t\t\t\tpruned[id] = entry;\n\t\t\t\tpending.push.apply(pending, iterable(entry.descendants).mapApply(function (id, pair) {\n\t\t\t\t\treturn pair[1][id];\n\t\t\t\t}).toArray());\n\t\t\t}\n\t\t}\n\t\treturn this.__entries__ = pruned;\n\t}\t\n}); // declare Cache\n","/** # Game tree\n\nA data structure to help building game trees, i.e. trees in which each node is a game state, the\nfinal states are leaves and each child node belongs to one of the next states of its parent.\n*/\nvar GameTree = utils.GameTree = declare({\n\t/** Each instance represents a node in the game tree. The `parent` must be null or undefined at\n\tthe root. The given `transition` is either the moves or the haps values used to move from the \n\tparent's state to this node's state. They also must be null or undefined at the root.\n\t*/\n\tconstructor: function GameTree(args) {\n\t\tthis.parent = args && args.parent;\n\t\tthis.state = args && args.state;\n\t\tthis.transition = args && args.transition;\n\t\tthis.probability = args && +args.probability;\n\t\tthis.children = args && args.children;\n\t\tif (this.state && !this.children) {\n\t\t\tthis.children = this.possibleTransitions();\n\t\t}\n\t},\n\t\n\t/** Returns the possible moves is the state is an instance of Game, or the possible haps values \n\tif the state is contingent.\n\t*/\n\tpossibleTransitions: function possibleTransitions() {\n\t\tvar state = this.state,\n\t\t\tCons = this.constructor,\n\t\t\tparent = this;\n\t\traiseIf(!state, \"GameTree node has no state!\");\n\t\tif (state.isContingent) {\n\t\t\treturn state.possibleHaps().map(function (t) {\n\t\t\t\tvar child = new Cons({ parent: parent, transition: t[0], probability: t[1] });\n\t\t\t\treturn child;\n\t\t\t});\n\t\t} else {\n\t\t\treturn state.possibleMoves().map(function (m) {\n\t\t\t\treturn new Cons({ parent: parent, transition: m });\n\t\t\t});\n\t\t}\n\t},\n\n\t/** This node's `children` are stored in an object, hence getting the count is a little tricky.\n\t*/\n\tchildrenCount: function childrenCount() {\n\t\tif (!this.children) {\n\t\t\tthis.children = this.possibleTransitions();\n\t\t}\n\t\treturn this.children.length;\n\t},\n\t\n\t__expandChild__: function __expandChild__(child) {\n\t\tif (!child.state) {\n\t\t\ttry {\n\t\t\t\tchild.state = child.parent.state.next(child.transition); \n\t\t\t} catch (err) {\n\t\t\t\traise(\"Node expansion for \", child.parent.state, \" with \", \n\t\t\t\t\tJSON.stringify(child.transition), \" failed with: \", err);\n\t\t\t}\n\t\t}\n\t\treturn child;\n\t},\n\n\t/** A node expansion takes the `moves` to calculate the next state and creates the child node\n\twith it. If the node already exists, it is returned and none is created.\n\t*/\n\texpand: function expand(i) {\n\t\traiseIf(i < 0 || i >= this.childrenCount(), \"Cannot expand children \", i, \"!\");\n\t\treturn this.__expandChild__(this.children[i]);\n\t},\n\t\n\t/** Expand a child at random.\n\t*/\n\texpandRandom: function expandRandom(random) {\n\t\trandom = random || Randomness.DEFAULT;\n\t\tvar pending = this.children.filter(function (child) {\n\t\t\treturn !child.state;\n\t\t});\n\t\treturn pending.length < 1 ? null :\n\t\t\tpending.length === 1 ? this.__expandChild__(pending[0]) :\n\t\t\tthis.__expandChild__(random.choice(pending));\n\t},\n\t\n\t/** A full expansion creates all children nodes for this node.\n\t*/\n\texpandAll: function expandAll() {\n\t\tvar child;\n\t\tfor (var i = 0, len = this.childrenCount; i < len; i++) {\n\t\t\tthis.__expandChild__(this.children[i]);\n\t\t}\n\t\treturn this.children;\n\t},\n\n\t// ## Utilities ###############################################################################\n\n\ttoString: function toString() { //FIXME\n\t\treturn 'GameTree('+ this.state +')';\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'GameTree',\n\t\tserializer: function serialize_GameTree(obj) {\n\t\t\treturn [{ \n\t\t\t\tparent: obj.parent, \n\t\t\t\tstate: obj.state, \n\t\t\t\ttransition: obj.transition, \n\t\t\t\tprobability: obj.probability,\n\t\t\t\tchildren: obj.children\n\t\t\t}];\n\t\t}\n\t}\n}); // declare GameTree","/** # RandomPlayer\n\nAutomatic players that moves fully randomly.\n*/\t\nplayers.RandomPlayer = declare(Player, {\n\t/** The constructor takes the player's `name` and a `random` number generator\n\t(`base.Randomness.DEFAULT` by default).\n\t*/\n\tconstructor: function RandomPlayer(params) {\n\t\tPlayer.call(this, params);\n\t\tvar prototype = Object.getPrototypeOf(this);\n\t\tinitialize(this, params)\n\t\t\t.object('random', { defaultValue: prototype.random });\n\t},\n\n\trandom: Randomness.DEFAULT,\n\n\t/** The `decision(game, player)` is made completely at random.\n\t*/\n\tdecision: function(game, player) {\n\t\traiseIf(game.isContingent, \"Contingent game state has no moves!\");\n\t\treturn this.random.choice(this.movesFor(game, player));\n\t},\n\t\n\t// ## Utilities ################################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'RandomPlayer',\n\t\tserializer: function serialize_RandomPlayer(obj) {\n\t\t\treturn this.serializeAsProperties(obj, ['name', 'random']);\n\t\t}\n\t},\n}); // declare RandomPlayer.\n","/** # TracePlayer\n\nAutomatic player that is scripted previously.\n*/\nplayers.TracePlayer = declare(Player, {\n\t/** The constructor takes the player's `name` and the `trace` as an sequence of moves to make.\n\t*/\n\tconstructor: function TracePlayer(params) {\n\t\tPlayer.call(this, params);\n\t\tthis.trace = iterable(params.trace);\n\t\tthis.__iter__ = this.trace.__iter__();\n\t\tthis.__decision__ = this.__iter__();\n\t},\n\n\t/** The `decision(game, player)` returns the next move in the trace, or the last one if the \n\ttrace has ended.\n\t*/\n\tdecision: function(game, player) {\n\t\ttry {\n\t\t\tthis.__decision__ = this.__iter__();\n\t\t} catch (err) {\n\t\t\tIterable.prototype.catchStop(err);\n\t\t}\n\t\treturn this.__decision__;\n\t},\n\t\n\t// ## Utilities ################################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'TracePlayer',\n\t\tserializer: function serialize_TracePlayer(obj) {\n\t\t\tvar ser = Player.__SERMAT__.serializer(obj),\n\t\t\t\targs = ser[0];\n\t\t\targs.trace = obj.trace.toArray();\n\t\t\treturn ser;\n\t\t}\n\t}\n}); // declare TracePlayer.\n","/** # HeuristicPlayer\n\nThis is the base type of automatic players based on heuristic evaluations of game states or moves.\n*/\n\nvar HeuristicPlayer = players.HeuristicPlayer = declare(Player, {\n\t/** The constructor takes the player's `name` and a `random` number generator \n\t(`base.Randomness.DEFAULT` by default). Many heuristic can be based on randomness, but this is \n\talso necessary to chose between moves with the same evaluation without any bias.\n\t*/\n\tconstructor: function HeuristicPlayer(params) {\n\t\tPlayer.call(this, params);\n\t\tvar prototype = Object.getPrototypeOf(this);\n\t\tinitialize(this, params)\n\t\t\t.func('heuristic', { ignore: true });\n\t},\n\n\t/** An `HeuristicPlayer` choses the best moves at any given game state. For this purpose it \n\tevaluates every move with `moveEvaluation(move, game, player)`. By default this function \n\tevaluates the states resulting from making each move, which is the most common thing to do.\n\t*/\n\tmoveEvaluation: function moveEvaluation(move, game, player) {\n\t\tvar heuristicPlayer = this;\n\t\tif (Object.keys(move).length < 2) { // One active player.\n\t\t\treturn this.stateEvaluation(game.next(move), player);\n\t\t} else { // Many active players.\n\t\t\tvar sum = 0, count = 0;\n\t\t\tmove = copy(obj(player, [move[player]]), move);\n\t\t\tgame.possibleMoves(move).forEach(function (ms) {\n\t\t\t\tsum += heuristicPlayer.stateEvaluation(game.next(ms), player);\n\t\t\t\t++count;\n\t\t\t});\n\t\t\treturn count > 0 ? sum / count : 0; // Average all evaluations.\n\t\t}\n\t},\n\n\t/** The `stateEvaluation(game, player)` calculates a number as the assessment of the given game \n\tstate for the given player. The base implementation returns the result for the player is the \n\tgame has results, else it returns the heuristic value for the state.\n\t*/\n\tstateEvaluation: function stateEvaluation(game, player) {\n\t\tif (!game.isContingent) {\n\t\t\tvar gameResult = game.result();\n\t\t\treturn gameResult ? gameResult[player] : this.heuristic(game, player);\n\t\t} else {\n\t\t\t/** Heuristics cannot be applied to contingent game states. Hence all posible haps are \n\t\t\texplored, and when a non-contingent game state is reached the heuristic is called.\n\t\t\t*/\n\t\t\treturn game.expectedEvaluation(player, this.stateEvaluation.bind(this));\n\t\t}\n\t},\n\t\n\t/** The `heuristic(game, player)` is an evaluation used at states that are not finished games. \n\tThe default implementation returns a random number in [-0.5, 0.5). This is only useful in \n\ttesting. Any serious use should redefine this.\n\t*/\n\theuristic: function heuristic(game, player) {\n\t\treturn this.random.random(-0.5, 0.5);\n\t},\n\t\n\t/** Heuristic players work by evaluating the moves of the `player` in the given `game` state. If\n\tthe game state is contingent, then all possible scenarios are evaluated and aggregated. The \n\tresult of `evaluatedMoves` is a sequence of pairs `[move, evaluation]`, or a future for such \n\tsequence if the evaluation function is asynchronous.\n\t*/\n\tevaluatedMoves: function evaluatedMoves(game, player) {\n\t\tvar heuristicPlayer = this,\n\t\t\tisAsync = false;\n\t\traiseIf(game.isContingent, \"Contingent game state has no moves!\");\n\t\t/** Every move is evaluated using `moveEvaluation`. This may be asynchronous and hence\n\t\tresult in a `Future`.\n\t\t*/\n\t\tvar result = this.possibleMoves(game, player).map(function (move) {\n\t\t\t\tvar e = heuristicPlayer.moveEvaluation(move, game, player);\n\t\t\t\tisAsync = isAsync || Future.__isFuture__(e);\n\t\t\t\treturn Future.then(e, function (e) {\n\t\t\t\t\treturn [move, e];\n\t\t\t\t});\n\t\t\t});\n\t\treturn isAsync ? Future.all(result) : result;\n\t}, // evaluatedMoves()\n\t\n\t/** The `possibleMoves` for a `player` in a given `game` is a set of objects, with one move for\n\tthe player, and all the options for the opponents.\n\t*/\n\tpossibleMoves: function possibleMoves(game, player) {\n\t\tvar moves = game.moves();\n\t\traiseIf(!moves || !moves[player] || !Array.isArray(moves[player]) || moves[player].length < 1,\n\t\t\t\"Player \"+ player +\" has no moves in \"+ game +\" (moves= \"+ moves +\")!\");\n\t\treturn moves[player].map(function (move) {\n\t\t\treturn copy(obj(player, move), moves);\n\t\t});\n\t},\n\t\n\t/** The `bestMoves(evaluatedMoves)` are all the best evaluated in the given sequence of tuples \n\t[move, evaluation].\n\t*/\n\tbestMoves: function bestMoves(evaluatedMoves) {\n\t\treturn Future.then(evaluatedMoves, function (evaluatedMoves) {\n\t\t\treturn iterable(evaluatedMoves).greater(function (pair) {\n\t\t\t\treturn pair[1];\n\t\t\t}).map(function (pair) {\n\t\t\t\treturn pair[0];\n\t\t\t});\n\t\t});\n\t},\n\t\n\t/** The `decision(game, player)` selects randomly from the best evaluated moves.\n\t*/\n\tdecision: function decision(game, player) {\n\t\tvar random = this.random;\n\t\treturn Future.then(this.bestMoves(this.evaluatedMoves(game, player)), function (bestMoves) {\n\t\t\traiseIf(!bestMoves || !bestMoves.length, \"No moves where selected at \", game,\n\t\t\t\t\" for player \", player, \"!\");\n\t\t\treturn random.choice(bestMoves)[player];\n\t\t});\n\t},\n\t\n\t// ## Utilities to build heuristics ############################################################\n\t\n\t/** A `composite` heuristic function returns the weighted sum of other functions. The arguments \n\tmust be a sequence of heuristic functions and a weight. All weights must be between 0 and 1 and\n\tadd up to 1.\n\t*/\n\t'static composite': function composite() {\n\t\tvar components = Array.prototype.slice.call(arguments), weightSum = 0;\n\t\traiseIf(components.length < 1,\n\t\t\t\"HeuristicPlayer.composite() cannot take an odd number of arguments!\");\n\t\tfor (var i = 0; i < components.length; i += 2) {\n\t\t\traiseIf(typeof components[i] !== 'function', \n\t\t\t\t\"HeuristicPlayer.composite() argument \", i, \" (\", components[i], \") is not a function!\");\n\t\t\tcomponents[i+1] = +components[i+1];\n\t\t\traiseIf(isNaN(components[i+1]) || components[i+1] < 0 || components[i+1] > 1, \n\t\t\t\t\"HeuristicPlayer.composite() argument \", i+1, \" (\", components[i+1], \") is not a valid weight!\");\n\t\t}\n\t\treturn function compositeHeuristic(game, player) {\n\t\t\tvar sum = 0;\n\t\t\tfor (var i = 0; i+1 < components.length; i += 2) {\n\t\t\t\tsum += components[i](game, player) * components[i+1];\n\t\t\t}\n\t\t\treturn sum;\n\t\t};\n\t},\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'HeuristicPlayer',\n\t\tserializer: function serialize_HeuristicPlayer(obj) {\n\t\t\tvar ser = Player.__SERMAT__.serializer(obj),\n\t\t\t\targs = ser[0];\n\t\t\tif (obj.hasOwnProperty('heuristic')) {\n\t\t\t\targs.heuristic = obj.heuristic;\n\t\t\t}\n\t\t\treturn ser;\n\t\t}\n\t}\n}); // declare HeuristicPlayer.","/** # MiniMaxPlayer\n\nAutomatic players based on pure MiniMax.\n*/\nvar MiniMaxPlayer = players.MiniMaxPlayer = declare(HeuristicPlayer, {\n\t/** The constructor takes the player's `name` and the MiniMax search's `horizon` (`4` by \n\tdefault).\n\t*/\n\tconstructor: function MiniMaxPlayer(params) {\n\t\tHeuristicPlayer.call(this, params);\n\t\tvar prototype = Object.getPrototypeOf(this);\n\t\tinitialize(this, params)\n\t\t\t.integer('horizon', { defaultValue: prototype.horizon, coerce: true });\n\t},\n\n\thorizon: 4,\n\n\t/** MiniMax players cannot be used with simultaneous games.\n\t*/\n\tisCompatibleWith: function isCompatibleWith(game) {\n\t\treturn !game.isSimultaneous;\n\t},\n\t\n\t/** Every state's evaluation is the minimax value for the given game and player.\n\t*/\n\tstateEvaluation: function stateEvaluation(game, player, options) {\n\t\treturn this.minimax(game, player, 1, options);\n\t},\n\n\t/** The `quiescence(game, player, depth)` method is a stability test for the given game state. \n\tIf the game is quiescent, this function must return an evaluation. Else it must return `NaN` or \n\tan equivalent value. \n\t\n\tFinal game states are always quiescent, and their evaluation is the game's result for the given \n\tplayer. This default implementation also return an heuristic evaluation for every game state at \n\ta deeper depth than the player's horizon.\n\t*/\n\tquiescence: function quiescence(game, player, depth) {\n\t\tvar results = game.result();\n\t\tif (results) {\n\t\t\treturn results[player];\n\t\t} else if (depth >= this.horizon) {\n\t\t\treturn this.heuristic(game, player);\n\t\t} else {\n\t\t\treturn NaN;\n\t\t}\n\t},\n\t\n\t/** The `minimax(game, player, depth, options)` method calculates the Minimax evaluation of the \n\tgiven game for the given player. If the game is not finished and the depth is greater than the \n\thorizon, `heuristic` is used.\n\t\n\tThe `options` optional argument may include:\n\n\t+ `hook`: A callback function to be called in every node with the game state and its value. A\n\tresult other than NaN overrides the minimax evaluation.\n\t*/\n\tminimax: function minimax(game, player, depth, options) {\n\t\tif (game.isContingent) {\n\t\t\treturn this.expectiMinimax(game, player, depth, options);\n\t\t}\n\t\tvar value = this.quiescence(game, player, depth);\n\t\tif (isNaN(value)) { // game is not quiescent.\n\t\t\tvar activePlayer = game.activePlayer(),\n\t\t\t\tmoves = this.movesFor(game, activePlayer), \n\t\t\t\tcomparison, next;\n\t\t\tif (moves.length < 1) {\n\t\t\t\tthrow new Error('No moves for unfinished game '+ game +'.');\n\t\t\t}\n\t\t\tif (activePlayer == player) {\n\t\t\t\tvalue = -Infinity;\n\t\t\t\tcomparison = Math.max;\n\t\t\t} else {\n\t\t\t\tvalue = +Infinity;\n\t\t\t\tcomparison = Math.min;\n\t\t\t}\n\t\t\tfor (var i = 0; i < moves.length; ++i) {\n\t\t\t\tnext = game.next(obj(activePlayer, moves[i]));\n\t\t\t\tvalue = comparison(value, this.minimax(next, player, depth + 1, options));\n\t\t\t}\n\t\t}\n\t\tif (options && typeof options.hook === 'function') {\n\t\t\tvar hookValue = options.hook(game, value);\n\t\t\tif (!isNaN(hookValue)) {\n\t\t\t\tvalue = hookValue;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t},\n\t\n\t/** The `expectiMinimax(game, player, depth)` method is used when calculating the minimax value\n\tof a contingent game state. Basically returns the sum of all the minimax values weighted by the \n\tprobability of each possible next state. \n\t*/\n\texpectiMinimax: function expectiMinimax(game, player, depth, options) {\n\t\tif (!game.isContingent) {\n\t\t\treturn this.minimax(game, player, depth, options);\n\t\t} else {\n\t\t\tvar p = this;\n\t\t\treturn game.expectedEvaluation(player, function (game, player) {\n\t\t\t\treturn p.minimax(game, player, depth + 1, options);\n\t\t\t});\n\t\t}\n\t},\n\t\n\t// ## Utilities ###############################################################################\n\t\n\t/** A `solution` calculates the minimax value for every game state derivable from the given \n\t`game`. The result is an object with a key for every game state, with a numerical value. The\n\tgame is assumed to be deterministic.\n\t\n\tThe optional `options` argument can have:\n\n\t+ `gameKey`: A function that returns a string key for every game state. The game `toString` \n\tmethod is used by default.\n\n\t+ `evals`: The object in which the solution is stored. A new object is used by default.\n\t*/\n\t'static solution': function solution(game, options) {\n\t\tvar evals = options && options.evals || {},\n\t\t\tmmPlayer = new this({ horizon: 1e8 }),\n\t\t\tgameKey = options.gameKey || function (game) {\n\t\t\t\treturn game.toString();\n\t\t\t};\n\t\tmmPlayer.minimax(game, game.activePlayer(), 0, { \n\t\t\thook: function (game, value) {\n\t\t\t\tvar k = gameKey(game);\n\t\t\t\traiseIf(evals.hasOwnProperty(k) && evals[k] !== value, \"Game \", game, \"(key \", \n\t\t\t\t\tk, \") has different values \", evals[k], \" and \", value, \"!\");\n\t\t\t\tevals[k] = value;\n\t\t\t}\n\t\t});\n\t\treturn evals;\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'MiniMaxPlayer',\n\t\tserializer: function serialize_MiniMaxPlayer(obj) {\n\t\t\tvar ser = HeuristicPlayer.__SERMAT__.serializer(obj),\n\t\t\t\targs = ser[0];\n\t\t\targs.horizon = obj.horizon;\n\t\t\treturn ser;\n\t\t}\n\t}\n}); // declare MiniMaxPlayer.","/** # MaxNPlayer\n\nAutomatic players based on the [MaxN](http://dl.acm.org/citation.cfm?id=2887795) algorithm, a \nMiniMax variant for games of more than two players.\n*/\nvar MaxNPlayer = players.MaxNPlayer = declare(HeuristicPlayer, {\n\t/** Besides the parameters of every [`HeuristicPlayer`](HeuristicPlayer.js.html), an `horizon` \n\tfor the search may be specified (3 plies by default).\n\t*/\n\tconstructor: function MaxNPlayer(params) {\n\t\tHeuristicPlayer.call(this, params);\n\t\tvar prototype = Object.getPrototypeOf(this);\n\t\tinitialize(this, params)\n\t\t\t.integer('horizon', { defaultValue: prototype.horizon, coerce: true });\n\t},\n\n\thorizon: 4,\n\n\t/** MaxN players cannot be used with simultaneous or non-deterministic games.\n\t*/\n\tisCompatibleWith: function isCompatibleWith(game) {\n\t\treturn !game.isSimultaneous && game.isDeterministic;\n\t},\n\t\n\t/** This player evaluates each state using the `maxn` method, taking the evaluation for the \n\tgiven `player`.\n\t*/\n\tstateEvaluation: function stateEvaluation(game, player) {\n\t\tif (!game.isContingent) {\n\t\t\treturn this.maxN(game, player, 0)[player];\n\t\t} else {\n\t\t\traise(\"MaxNPlayer.stateEvalution() does not support contingent game states!\"); //TODO\n\t\t}\n\t},\n\n\t/** `heuristics(game)` returns an heuristic value for each players in the game, as an object.\n\t*/\n\theuristics: function heuristics(game) {\n\t\tvar result = {}, maxN = this;\n\t\tgame.players.forEach(function (role) {\n\t\t\tresult[role] = maxN.heuristic(game, role);\n\t\t});\n\t\treturn result;\n\t},\n\n\t/** `quiescence(game, player, depth)` is a stability test for the given `game` state and the \n\tgiven `player`. If the game is quiescent, this function must return evaluations. Else it must \n\treturn null. \n\t\n\tFinal game states are always quiescent, and their evaluations are the game's result for each \n\tplayer. This default implementation also returns heuristic evaluations for every game state at \n\ta deeper depth than the player's horizon, calculated via the `heuristics()` method. \n\t*/\n\tquiescence: function quiescence(game, player, depth) {\n\t\tvar results = game.result();\n\t\tif (results) {\n\t\t\treturn results;\n\t\t} else if (depth >= this.horizon) {\n\t\t\treturn this.heuristics(game);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\t\n\t/** The core `maxN(game, player, depth)` algorithm return the evaluations for each player of the \n\tgiven game, assuming each player tries to maximize its own evaluation regardless of the others'.\n\t*/\n\tmaxN: function maxN(game, player, depth) {\n\t\tvar values = this.quiescence(game, player, depth);\n\t\tif (!values) { // game is not quiescent.\n\t\t\tvar activePlayer = game.activePlayer(),\n\t\t\t\tmoves = this.movesFor(game, activePlayer),\n\t\t\t\totherValues, next;\n\t\t\tvalues = {};\n\t\t\tif (moves.length < 1) {\n\t\t\t\tthrow new Error('No moves for unfinished game '+ game +'.');\n\t\t\t}\n\t\t\tfor (var i = 0; i < moves.length; ++i) {\n\t\t\t\tnext = game.next(obj(activePlayer, moves[i]));\n\t\t\t\totherValues = this.maxN(next, player, depth + 1);\n\t\t\t\tif (otherValues[activePlayer] > (values[activePlayer] || -Infinity)) {\n\t\t\t\t\tvalues = otherValues;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t},\n\t\n\t// ## Utilities ################################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'MaxNPlayer',\n\t\tserializer: function serialize_MaxNPlayer(obj) {\n\t\t\tvar ser = HeuristicPlayer.__SERMAT__.serializer(obj),\n\t\t\t\targs = ser[0];\n\t\t\targs.horizon = obj.horizon;\n\t\t\treturn ser;\n\t\t}\n\t}\n}); // declare MaxNPlayer.","/** # AlphaBetaPlayer\n\nAutomatic players based on MiniMax with alfa-beta pruning.\n*/\nplayers.AlphaBetaPlayer = declare(MiniMaxPlayer, {\n\t/** The constructor does not add anything to the parent\n\t[`MiniMaxPlayer`](MiniMaxPlayer.js.html) constructor.\n\t*/\n\tconstructor: function AlphaBetaPlayer(params) {\n\t\tMiniMaxPlayer.call(this, params);\n\t},\n\n\t/** Every state's evaluation is the minimax value for the given game and \n\tplayer. The alfa an beta arguments are initialized with `-Infinity` and\n\t`Infinity`.\n\t*/\n\tstateEvaluation: function stateEvaluation(game, player) {\n\t\treturn this.minimax(game, player, 1, -Infinity, Infinity);\n\t},\n\n\t/** The `minimax(game, player, depth, alfa, beta)` method calculates the \n\tMinimax evaluation of the given game for the given player. If the game is \n\tnot finished and the depth is greater than the horizon, the heuristic is\n\tused.\n\t*/\n\tminimax: function minimax(game, player, depth, alpha, beta) {\n\t\tif (game.isContingent) {\n\t\t\treturn this.expectiMinimax(game, player, depth, alpha, beta);\n\t\t}\n\t\tvar value = this.quiescence(game, player, depth);\n\t\tif (!isNaN(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tvar activePlayer = game.activePlayer(),\n\t\t\tisActive = activePlayer == player,\n\t\t\tmoves = this.movesFor(game, activePlayer), next;\n\t\tif (moves.length < 1) {\n\t\t\traise(\"No moves for unfinished game \"+ game +\"!\");\n\t\t}\n\t\tfor (var i = 0; i < moves.length; i++) {\n\t\t\tnext = game.next(obj(activePlayer, moves[i]));\n\t\t\tvalue = this.minimax(next, player, depth + 1, alpha, beta);\n\t\t\tif (isActive) {\n\t\t\t\tif (alpha < value) { // MAX\n\t\t\t\t\talpha = value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (beta > value) { // MIN\n\t\t\t\t\tbeta = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (beta <= alpha) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn isActive ? alpha : beta;\n\t},\n\t\n\t/** The `expectiMinimax(game, player, depth)` method is used when calculating the minimax value\n\tof a contingent game state. Basically returns the sum of all the minimax values weighted by the \n\tprobability of each possible next state. \n\t*/\n\texpectiMinimax: function expectiMinimax(game, player, depth, alpha, beta) {\n\t\tif (!game.isContingent) {\n\t\t\treturn this.minimax(game, player, depth);\n\t\t} else {\n\t\t\tvar p = this;\n\t\t\treturn game.expectedEvaluation(player, function (game, player) {\n\t\t\t\treturn p.minimax(game, player, depth + 1, alpha, beta);\n\t\t\t});\n\t\t}\n\t},\n\t\n\t// ## Utilities ################################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'AlphaBetaPlayer',\n\t\tserializer: function serialize_AlphaBetaPlayer(obj) {\n\t\t\treturn MiniMaxPlayer.__SERMAT__.serializer(obj);\n\t\t}\n\t}\n}); // declare AlphaBetaPlayer.\n","/** # MonteCarloPlayer\n\nAutomatic player based on flat Monte Carlo tree search.\n*/\nvar MonteCarloPlayer = players.MonteCarloPlayer = declare(HeuristicPlayer, {\n\t/** The constructor builds a player that chooses its moves using the\n\t[flat Monte Carlo game tree search method](http://en.wikipedia.org/wiki/Monte-Carlo_tree_search).\n\tThe parameters may include:\n\n\t+ `simulationCount=30`: Maximum amount of simulations performed for each available move at each\n\t\tdecision.\n\t+ `timeCap=1000ms`: Time limit for the player to decide.\n\t+ `horizon=500`: Maximum amount of moves performed in simulations.\n\t+ `agent`: Player instance used in the simulations. If undefined moves are chosen at random.\n\t\tAgents with asynchronous decisions are not supported.\n\t*/\n\tconstructor: function MonteCarloPlayer(params) {\n\t\tHeuristicPlayer.call(this, params);\n\t\tvar prototype = Object.getPrototypeOf(this);\n\t\tinitialize(this, params)\n\t\t\t.number('simulationCount', { defaultValue: prototype.simulationCount, coerce: true })\n\t\t\t.number('timeCap', { defaultValue: prototype.timeCap, coerce: true })\n\t\t\t.number('horizon', { defaultValue: prototype.horizon, coerce: true });\n\t\tif (params) switch (typeof params.agent) {\n\t\t\tcase 'function': this.agent = new HeuristicPlayer({ heuristic: params.agent }); break;\n\t\t\tcase 'object': this.agent = params.agent; break;\n\t\t\tdefault: this.agent = null;\n\t\t}\n\t},\n\n\tsimulationCount: 30,\n\ttimeCap: 1000,\n\thorizon: 500,\n\n\t/** `evaluatedMoves(game, player)` returns a sequence with the evaluated moves.\n\t*/\n\tevaluatedMoves: function evaluatedMoves(game, player) {\n\t\traiseIf(game.isContingent, \"MonteCarloPlayer cannot evaluate root contingent states!\"); //FIXME\n\t\tvar monteCarloPlayer = this,\n\t\t\tstartTime = Date.now(),\n\t\t\toptions = this.possibleMoves(game, player).map(function (move) {\n\t\t\t\treturn {\n\t\t\t\t\tmove: move,\n\t\t\t\t\tnexts: (Object.keys(move).length < 2 ?\n\t\t\t\t\t\t[game.next(move)] :\n\t\t\t\t\t\tgame.possibleMoves(copy(obj(player, [move[player]]), move)).map(function (moves) {\n\t\t\t\t\t\t\treturn game.next(moves);\n\t\t\t\t\t\t})\n\t\t\t\t\t),\n\t\t\t\t\tsum: 0,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\t\t\t}); // Else the following updates won't work.\n\t\tfor (var i = 0; !this.__finishMoveEvaluation__(i, startTime, options); ) {\n\t\t\toptions.forEach(function (option) {\n\t\t\t\toption.nexts = option.nexts.filter(function (next) {\n\t\t\t\t\tvar sim = monteCarloPlayer.simulation(next, player);\n\t\t\t\t\toption.sum += sim.result;\n\t\t\t\t\t++option.count;\n\t\t\t\t\treturn sim.plies > 0;\n\t\t\t\t});\n\t\t\t\ti++;\n\t\t\t});\n\t\t}\n\t\treturn options.map(function (option) {\n\t\t\traiseIf(isNaN(option.sum), \"State evaluation is NaN for move \", option.move, \"!\");\n\t\t\treturn [option.move, option.count > 0 ? option.sum / option.count : 0, option.count];\n\t\t});\n\t},\n\n\t/** The move evaluation can be finished on many criteria. By default, `simulationCount` and \n\t`timeCap` are considered.\n\t*/\n\t__finishMoveEvaluation__: function __finishMoveEvaluation__(simCount, startTime, data) {\n\t\treturn simCount > this.simulationCount || startTime + this.timeCap < Date.now();\n\t},\n\n\t/** This player's `stateEvaluation(game, player)` runs `simulationCount` simulations and returns\n\tthe average result. It is provided for compatibility, since `evaluatedMoves` does not call it.\n\t*/\n\tstateEvaluation: function stateEvaluation(game, player) {\n\t\tvar resultSum = 0,\n\t\t\tsimulationCount = this.simulationCount,\n\t\t\tsim;\n\t\tfor (var i = 0; i < simulationCount; ++i) {\n\t\t\tsim = this.simulation(game, player);\n\t\t\tresultSum += sim.result[player];\n\t\t\tif (sim.plies < 1) { // game is final.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn simulationCount > 0 ? resultSum / simulationCount : 0;\n\t},\n\n\t/**TODO\n\t*/\n\tquiescence: function quiescence(game, player, depth) {\n\t\tvar result = game.result();\n\t\tif (result) {\n\t\t\treturn result[player];\n\t\t} else if (depth >= this.horizon) {\n\t\t\treturn this.heuristic(game, player);\n\t\t} else {\n\t\t\treturn NaN;\n\t\t}\n\t},\n\n\t/** A `simulation(game, player)` plays a random match from the given `game` state and returns an\n\tobject with the final state (`game`), its result (`result`) and the number of plies simulated\n\t(`plies`).\n\t*/\n\tsimulation: function simulation(game, player) {\n\t\tvar result = { game: game },\n\t\t\tplies;\n\t\tfor (plies = 0; true; ++plies) {\n\t\t\tif (game.isContingent) {\n\t\t\t\tgame = game.randomNext(this.random);\n\t\t\t} else {\n\t\t\t\tvar q = this.quiescence(game, player, plies + 1);\n\t\t\t\tif (isNaN(q)) { // The simulation continues.\n\t\t\t\t\tgame = game.randomNext(this.random, plies > 0).state; // The original `game` argument must not be changed.\n\t\t\t\t} else { // The simulation has a result and ends.\n\t\t\t\t\tresult.result = q;\n\t\t\t\t\tresult.plies = plies;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\traise(\"Simulation ended unexpectedly for player \", player, \" in game \", game, \"!\");\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'MonteCarloPlayer',\n\t\tserializer: function serialize_MonteCarloPlayer(obj) {\n\t\t\tvar ser = HeuristicPlayer.__SERMAT__.serializer(obj),\n\t\t\t\targs = ser[0];\n\t\t\targs.simulationCount = obj.simulationCount;\n\t\t\targs.timeCap = obj.timeCap;\n\t\t\targs.horizon = obj.horizon;\n\t\t\tif (obj.agent) {\n\t\t\t\targs.agent = obj.agent;\n\t\t\t}\n\t\t\treturn ser;\n\t\t}\n\t}\n}); // declare MonteCarloPlayer\n","/** # UCTPlayer\n\nAutomatic player based on Upper Confidence Bound Monte Carlo tree search.\n*/\nplayers.UCTPlayer = declare(MonteCarloPlayer, {\n\t/** The constructor parameters may include:\n\n\t+ `simulationCount`: Maximum amount of simulations performed at each decision.\n\t+ `timeCap`: Time limit for the player to decide.\n\t*/\n\tconstructor: function UCTPlayer(params) {\n\t\tMonteCarloPlayer.call(this, params);\n\t\tvar prototype = Object.getPrototypeOf(this);\n\t\tinitialize(this, params)\n\t\t/** + `explorationConstant=sqrt(2)`: The exploration factor used in the UCT selection.\n\t\t*/\n\t\t\t.number('explorationConstant', { defaultValue: prototype.explorationConstant, coerce: true })\n\t\t;\n\t},\n\n\texplorationConstant: Math.sqrt(2),\n\n\t/** Evaluate all child nodes of the given `node` according to the [Upper Confidence Bound\n\tformula by L. Kocsis and Cs. Szepesvri](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.1296).\n\tReturns one of the greatest evaluated, chosen at random.\n\t*/\n\tselectNode: function selectNode(parent, totalSimulationCount, explorationConstant) {\n\t\texplorationConstant = isNaN(explorationConstant) ? this.explorationConstant : +explorationConstant;\n\t\treturn this.random.choice(iterable(parent.children).greater(function (node) {\n\t\t\traiseIf(!node.uct, 'Invalid UCT node `'+ node +'` under `'+ parent +'`!');//FIXME\n\t\t\tvar visits = node.uct.visits;\n\t\t\treturn (node.uct.rewards + visits) / visits / 2 +\n\t\t\t\texplorationConstant * Math.sqrt(Math.log(parent.uct.visits) / visits);\n\t\t}));\n\t},\n\n\t/** `evaluatedMoves(game, player)` return a sequence with the evaluated moves.\n\t*/\n\tevaluatedMoves: function evaluatedMoves(game, player) {\n\t\tvar root = new GameTree({ state: game }),\n\t\t\tstartTime = Date.now(),\n\t\t\tnode, simulationResult;\n\t\troot.uct = { pending: root.childrenCount(), visits: 0, rewards: 0 };\n\t\tfor (var i = 0;  !this.__finishMoveEvaluation__(i, startTime, root); i++) {\n\t\t\tnode = root;\n\t\t\twhile (node.uct.pending < 1 && node.childrenCount() > 0) { // Selection\n\t\t\t\tnode = this.selectNode(node, i+1, this.explorationConstant);\n\t\t\t}\n\t\t\tif (node.uct.pending > 0) { // Expansion\n\t\t\t\tnode.uct.pending--;\n\t\t\t\tnode = node.expandRandom(this.random);\n\t\t\t\tnode.uct = { pending: node.childrenCount(), visits: 0, rewards: 0 };\n\t\t\t}\n\t\t\tsimulationResult = this.simulation(node.state, player); // Simulation\n\t\t\tfor (; node; node = node.parent) { // Backpropagation\n\t\t\t\tnode.uct.visits++;\n\t\t\t\tnode.uct.rewards += game.normalizedResult(simulationResult.result);\n\t\t\t}\n\t\t}\n\t\tvar result = iterable(root.children).map(function (n) {\n\t\t\t\treturn n.uct ?\n\t\t\t\t\t[n.transition, n.uct.rewards / n.uct.visits, n.uct.visits] :\n\t\t\t\t\t[n.transition, 0, 0]; //FIXME Is 0 for unevaluated nodes OK? \n\t\t\t}).toArray();\n\t\t//console.log(root);//FIXME\n\t\tconsole.log(result);//FIXME\n\t\treturn result;\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'UCTPlayer',\n\t\tserializer: function serialize_UCTPlayer(obj) {\n\t\t\tvar ser = MonteCarloPlayer.__SERMAT__.serializer(obj),\n\t\t\t\targs = ser[0];\n\t\t\targs.explorationConstant = obj.explorationConstant;\n\t\t\treturn ser;\n\t\t}\n\t}\n}); // declare UCTPlayer\n","/** # Rule based players\n\nAutomatic players based on rules, either for evaluating game states or to choose moves.\n*/\nplayers.RuleBasedPlayer = declare(Player, {\n\t/** todo\n\t*/\n\tconstructor: function RuleBasedPlayer(params) {\n\t\tPlayer.call(this, params);\n\t\tinitialize(this, params)\n\t\t\t/** + `rules` must be an array of functions that return either a move (if the rule \n\t\t\t\tapplies) or `null` (if the rule does not apply).\n\t\t\t*/\n\t\t\t.array('rules', { defaultValue: [] })\n\t\t\t/** + ``\n\t\t\t*/\n\t\t\t.func('features', { ignore: true });\n\t},\n\n\t/** This function extracts the relevant `features` of the given game state. These data is the\n\tone passed to the rules.\n\t*/\n\tfeatures: function features(game, role) {\n\t\treturn [game, role]; // Please override.\n\t},\n\t\n\t/** To choose a move, the `rules` are checked in order. The first rule that fits decides the\n\tmove to make. If no rule fits, a move is chosen randomly. If a rule returns a move that is not\n\tvalid, it is ignored.\n\t*/\n\tdecision: function decision(game, role) {\n\t\tvar result = null,\n\t\t\tfeatures = this.features(game, role),\n\t\t\tmoves = this.movesFor(game, role);\n\t\tfor (var i = 0, len = this.rules.length; i < len; i++) {\n\t\t\tresult = this.rules[i].call(this, features);\n\t\t\tif (result !== null && moves.indexOf(result) >= 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn this.random.choice(moves);\n\t},\n\t\n\t/** The rule method adds a rule to the players' list of rules.\n\t*/\n\trule: function rule(f) {\n\t\traiseIf(typeof(f) !== 'function', 'A rule must be in the form of a function!');\n\t\tthis.rules.push(f);\n\t\treturn this; // for chaining.\n\t},\n\t\n\t// ## Rule definition helpers ##################################################################\n\t\n\t/** The class `regExpRule` method builds a rule function based on a regular expression.\n\t*/\n\t'static regExpRule': function regExpRule(regExp, move) {\n\t\treturn function (features) {\n\t\t\treturn regExp.test(features) ? move : null;\n\t\t};\n\t},\n\t\n\t/** The instance method `regExpRule` adds a rule based on a regular expression to the players'\n\tlist of rules.\n\t*/\n\tregExpRule: function regExpRule(regExp, move) {\n\t\treturn this.rule(this.constructor.regExpRule(regExp, move));\n\t},\n\t\n\t// ## Rule based heuristics ####################################################################\n\t\n\t// ## Other utilities ##########################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'RuleBasedPlayer',\n\t\tserializer: function serialize_Player(obj) {\n\t\t\tvar ser = Player.__SERMAT__.serializer(obj),\n\t\t\t\targs = ser[0];\n\t\t\targs.rules = obj.rules;\n\t\t\tif (obj.hasOwnProperty('features')) {\n\t\t\t\targs.features = obj.features;\n\t\t\t}\n\t\t\treturn ser;\n\t\t}\n\t}\n}); // declare RulePlayer.","/** # EnsemblePlayer\n\nPlayers defined as a combination of other players.\n*/\nplayers.EnsemblePlayer = declare(Player, {\n\t/** The constructor takes the player's `name`, a `random` number generator\n\t(`base.Randomness.DEFAULT` by default), and (optionally) an array of `players`.\n\t*/\n\tconstructor: function EnsemblePlayer(params) {\n\t\tPlayer.call(this, params);\n\t\tinitialize(this, params)\n\t\t\t.array('players', { ignore: true });\n\t},\n\n\tplayers: [],\n\n\t/** The `playerSelection` returns a subset of all `players` which can be used to decide on the\n\tgiven `game` state. By default all players are selected.\n\t*/\n\tplayerSelection: function playerSelection(game, role) {\n\t\treturn this.players;\n\t},\n\n\t/** By default one of the selected players is chosen at random.\n\t*/\n\tdecision: function(game, role) {\n\t\treturn this.randomDecision(game, role);\n\t},\n\n\t// ## Posible combinations ####################################################################\n\n\t/** A `randomDecision` delegates the decision to one of the available `players` chosen at\n\trandom.\n\t*/\n\trandomDecision: function randomDecision(game, role, players) {\n\t\tplayers = players || this.playerSelection(game, role);\n\t\traiseIf(players.length < 1, \"No player was selected!\");\n\t\treturn (players.length == 1 ? players[0] : this.random.choice(players))\n\t\t\t.decision(game, role);\n\t},\n\n\t/** An `heuristicCombination` makes a decision by evaluating the available actions with all the\n\tplayers in the ensemble, combining the results and choosing the best evaluated move (or one of\n\tthe best evaluated ones at random, if more than one action has the best evaluation).\n\t*/\n\theuristicCombination: (function () {\n\t\tfunction average(move, evals, game, role) {\n\t\t\treturn iterable(evals).sum() / evals.length;\n\t\t}\n\n\t\treturn function heuristicCombination(aggregation) {\n\t\t\taggregation = aggregation || average;\n\n\t\t\treturn function combinedHeuristicDecision(game, role, players) {\n\t\t\t\tplayers = players || this.playerSelection(game, role);\n\t\t\t\tvar isAsync = false,\n\t\t\t\t\tplayer = this,\n\t\t\t\t\tds = players.map(function (p) {\n\t\t\t\t\t\traiseIf(!p.evaluatedMoves, \"Cannot call `evaluatedMoves()` on player \", p.name, \"(\", p.constructor.name, \")!\");\n\t\t\t\t\t\tvar d = p.evaluatedMoves(game, role);\n\t\t\t\t\t\tisAsync = isAsync || Future.__isFuture__(d);\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t});\n\t\t\t\tif (isAsync) {\n\t\t\t\t\treturn Future.all(ds).then(function (evaluatedMoves) {\n\t\t\t\t\t\treturn player.__bestAggregatedEvaluationMove__(game, role, aggregation, evaluatedMoves);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn player.__bestAggregatedEvaluationMove__(game, role, aggregation, ds);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t})(),\n\n\t__aggregateEvaluatedMoves__: function __aggregateEvaluatedMoves__(game, role, aggregation, evaluatedMoves) {\n\t\tvar grouped = iterable(evaluatedMoves).flatten().groupAll(function (evm) {\n\t\t\treturn JSON.stringify(evm[0]); //TODO Allow to customize\n\t\t}, function (evs, evm) {\n\t\t\tif (evs) {\n\t\t\t\tevs[1].push(evm[1]);\n\t\t\t\treturn evs;\n\t\t\t} else {\n\t\t\t\treturn [evm[0], [evm[1]]];\n\t\t\t}\n\t\t});\n\t\treturn iterable(grouped).mapApply(function (k, v) {\n\t\t\treturn [v[0], aggregation(v[0], v[1], game, role)];\n\t\t});\n\t},\n\n\t__bestAggregatedEvaluationMove__: function __bestAggregatedEvaluationMove__(game, role, aggregation, evaluatedMoves) {\n\t\tvar aggregated = this.__aggregateEvaluatedMoves__(game, role, aggregation, evaluatedMoves);\n\t\traiseIf(aggregated.isEmpty(), \"There are no evaluated moves for \", role, \" to choose from in \", game, \"!\");\n\t\tvar bestMoves = HeuristicPlayer.prototype.bestMoves(aggregated),\n\t\t\tbestMove = this.random.choice(bestMoves);\n\t\treturn bestMove[role];\n\t},\n\n\t// ## Utilities ###############################################################################\n\n\t'static parallelizeHeuristicPlayer': function parallelizeHeuristicPlayer(amount, webWorkerParams) {\n\t\tamount = amount || navigator.hardwareConcurrency;\n\t\tvar fs = base.Iterable.range(amount).map(function () {\n\t\t\t\treturn ludorum.players.WebWorkerPlayer.create(webWorkerParams);\n\t\t\t}),\n\t\t\tEnsemblePlayer = this;\n\t\treturn base.Future.all(fs.toArray()).then(function (players) {\n\t\t\tvar p = new EnsemblePlayer({ players: players });\n\t\t\tp.decision = p.heuristicCombination();\n\t\t\treturn p;\n\t\t});\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'EnsemblePlayer',\n\t\tserializer: function serialize_EnsemblePlayer(obj) {\n\t\t\treturn this.serializeAsProperties(obj, ['name', 'random', 'players']);\n\t\t}\n\t},\n}); // declare RandomPlayer.\n","/** # UserInterfacePlayer\n\nImplementation of player user interfaces and proxies.\n*/\nvar UserInterfacePlayer = players.UserInterfacePlayer = declare(Player, {\n\t/** `UserInterfacePlayer` is a generic type for all players that are proxies of user interfaces.\n\t*/\n\tconstructor: function UserInterfacePlayer(params) {\n\t\tPlayer.call(this, params);\n\t},\n\n\t/** The `participate` method assigns this players role to the given role.\n\t*/\n\tparticipate: function participate(match, role) {\n\t\tthis.role = role;\n\t\treturn this;\n\t},\n\t\n\t/** The `decision(game, player)` of this players returns a future that will be resolved when the \n\t`perform()` method is called.\n\t*/\n\tdecision: function decision(game, player) {\n\t\tif (this.__future__ && this.__future__.isPending()) {\n\t\t\tthis.__future__.resolve(new Match.commands.Quit());\n\t\t}\n\t\tthis.__future__ = new Future();\n\t\treturn this.__future__;\n\t},\n\t\n\t/**  User interfaces have to be configured to call `perform(action)` upon each significant user \n\taction.players. It resolves the future returned by the `decision()` method.\n\t*/\n\tperform: function perform(action) {\n\t\tvar future = this.__future__;\n\t\tif (future) {\n\t\t\tthis.__future__ = null;\n\t\t\tfuture.resolve(action);\n\t\t}\n\t\treturn !!future;\n\t}\n}); // declare UserInterfacePlayer.\n\n// ## User interfaces ##############################################################################\n\nvar UserInterface = players.UserInterface = declare({\n\t/** `UserInterface` is the base abstract type for user interfaces that display a game and allow \n\tone or more players to play. The `config` argument may include the `match` being played.\n\t*/\n\tconstructor: function UserInterface(config) {\n\t\tthis.onBegin = this.onBegin.bind(this);\n\t\tthis.onNext = this.onNext.bind(this);\n\t\tthis.onEnd = this.onEnd.bind(this);\n\t\tif (config.match) {\n\t\t\tthis.show(config.match);\n\t\t}\n\t},\n\t\n\t/** `show(match)` discards the current state and sets up to display the given `match`.\n\t*/\n\tshow: function show(match) {\n\t\tif (this.match) {\n\t\t\tmatch.events.off('begin', this.onBegin);\n\t\t\tmatch.events.off('next', this.onNext);\n\t\t\tmatch.events.off('end', this.onEnd);\n\t\t}\n\t\tthis.match = match;\n\t\tmatch.events.on('begin', this.onBegin);\n\t\tmatch.events.on('next', this.onNext);\n\t\tmatch.events.on('end', this.onEnd);\n\t},\n\t\n\t/** When the player is participated of a match, callbacks are registered to the following \n\tmatch's events.\n\t\n\t+ `onBegin(game)` handles the `'begin'` event of the match.\n\t*/\n\tonBegin: function onBegin(game) {\n\t\tthis.display(game);\n\t},\n\t\n\t/** + `onNext(game, moves, haps, next)` handles the `'move'` event of the match.\n\t*/\n\tonNext: function onNext(game, moves, haps, next) {\n\t\tthis.display(next);\n\t},\n\t\n\t/** + `onEnd(game, results)` handles the `'end'` event of the match.\n\t*/\n\tonEnd: function onEnd(game, results) {\n\t\tthis.results = results;\n\t\tthis.display(game);\n\t},\n\t\n\t/** `display(game)` renders the game in this user interface. Not implemented, so please \n\toverride.\n\t*/\n\tdisplay: unimplemented(\"UserInterface\", \"display\"),\n\t\n\t/** `perform(action, actionRole=undefined)` makes the given player perform the action if the \n\tplayer has a `perform()` method and is included in this UI's players.\n\t*/\n\tperform: function perform(action, actionRole) {\n\t\titerable(this.match.players).forEach(function (pair) {\n\t\t\tvar role = pair[0], player = pair[1];\n\t\t\tif (player instanceof UserInterfacePlayer && (!actionRole || player.role === actionRole)) {\n\t\t\t\tplayer.perform(action);\n\t\t\t}\n\t\t});\n\t}\n}); // declare UserInterface.\n\n// ### HTML based user interfaces ##################################################################\n\nUserInterface.BasicHTMLInterface = declare(UserInterface, {\n\t/** `BasicHTMLInterface(config)` builds a simple HTML based UI, that renders the game on the DOM \n\tusing its `display()` method. The `config` argument may include:\n\t\n\t+ `document=window.document`: the DOM root.\n\t+ `container`: the DOM node to render the game in, or its name.\n\t*/\n\tconstructor: function BasicHTMLInterface(config) {\n\t\tUserInterface.call(this, config);\n\t\tthis.document = config.document || base.global.document;\n\t\tthis.container = config.container;\n\t\tif (typeof this.container === 'string') {\n\t\t\tthis.container = this.document.getElementById(this.container);\n\t\t}\n\t},\n\n\t/** On `display(game)` the `container` is emptied and the game is rendered using its \n\t`display(ui)` method.\n\t*/\n\tdisplay: function display(game) {\n\t\tvar container = this.container, child;\n\t\twhile (child = container.firstChild) { // It seems the DOM API does not provide a method for this. :-(\n\t\t\tcontainer.removeChild(child);\n\t\t}\n\t\tgame.display(this);\n\t},\n\t\n\t/** `build()` helps DOM creation. The `nodes` argument specifies DOM elements, each with an \n\tarray of the shape: `[tag, attributes, elements]`.\n\t*/\n\tbuild: function build(parent, nodes) {\n\t\tvar ui = this;\n\t\tnodes.forEach(function (node) {\n\t\t\tvar element;\n\t\t\tif (Array.isArray(node)) {\n\t\t\t\telement = ui.document.createElement(node[0]);\n\t\t\t\tif (node.length > 2 && node[1]) { // There are attributes.\n\t\t\t\t\tvar attrs = node[1];\n\t\t\t\t\tfor (var attrName in attrs) if (attr.hasOwnProperty(attrName)) {\n\t\t\t\t\t\telement.setAttribute(attrName, attrs[attrName]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (node.length > 1 && node[node.length-1]) { // There are child elements.\n\t\t\t\t\tui.build(element, node[node.length-1]);\n\t\t\t\t}\n\t\t\t} else if (typeof node === 'string') {\n\t\t\t\telement = ui.document.createTextNode(node);\n\t\t\t}\n\t\t\tif (element && parent) {\n\t\t\t\tparent.appendChild(element);\n\t\t\t}\n\t\t});\n\t\treturn parent;\n\t}\n}); // declare HTMLInterface.\n","/** # WebWorkerPlayer\n\nA proxy for another player executing inside a webworker.\n*/\nvar WebWorkerPlayer = players.WebWorkerPlayer = declare(Player, {\n\t/** The constructor builds a player that is a proxy for another player executing in a webworker.\n\tThe parameters must include:\n\t*/\n\tconstructor: function WebWorkerPlayer(params) {\n\t\tPlayer.call(this, params);\n\t\tinitialize(this, params)\n\t\t\t/** + `worker`: The `Worker` instance where the actual player is executing.\n\t\t\t*/\n\t\t\t.object('worker');\n\t\tthis.worker.onmessage = base.Parallel.prototype.__onmessage__.bind(this);\n\t},\n\n\t/** The static `createWorker(playerBuilder)` method creates (asynchronously) and initializes a\n\tweb worker. The modules `creatartis-base` and `ludorum` are loaded in the webworker's root\n\tnamespace (`self`). If a `workerSetup` function is given, it is also run. After that, the\n\t`playerBuilder` function is called and its results stored in the variable `self.PLAYER`.\n\t*/\n\t'static createWorker': function createWorker(params) {\n\t\traiseIf('string function'.indexOf(typeof params.playerBuilder) < 0,\n\t\t\t\"Invalid player builder: \"+ params.playerBuilder +\"!\");\n\t\traiseIf(params.workerSetup && 'string function'.indexOf(typeof params.workerSetup) < 0,\n\t\t\t\"Invalid worker setup: \"+ params.workerSetup +\"!\");\n\t\tvar parallel = new base.Parallel(),\n\t\t\tdeps = [exports].concat(params.dependencies || []);\n\t\treturn Future.sequence(deps, function (dependency) {\n\t\t\t\treturn parallel.loadModule(dependency, true);\n\t\t\t}).then(function () {\n\t\t\t\treturn parallel.run(\n\t\t\t\t\t(params.workerSetup ? '('+ params.workerSetup +')(),\\n' : '')+\n\t\t\t\t\t'self.PLAYER = ('+ params.playerBuilder +').call(self),\\n'+\n\t\t\t\t\t'\"OK\"');\n\t\t\t}).then(function () {\n\t\t\t\tvar worker = parallel.worker;\n\t\t\t\tworker.__parallel__ = parallel;\n\t\t\t\treturn worker;\n\t\t\t});\n\t},\n\n\t/** The static `create(params)` method creates (asynchronously) and initializes a\n\t`WebWorkerPlayer`, with a web worker ready to play. The `params` must include the\n\t`playerBuilder` function to execute on the web worker's environment.\n\t*/\n\t'static create': function create(params) {\n\t\tvar WebWorkerPlayer = this;\n\t\treturn WebWorkerPlayer.createWorker(params).then(function (worker) {\n\t\t\treturn new WebWorkerPlayer({name: name, worker: worker});\n\t\t});\n\t},\n\n\t/** The webworker player stores the future of the current computation in the `__future__`\n\tproperty. If one code is executed in the webworker before a previous one ends, the previous one\n\tgets resolved with a `cancelValue` or rejected.\n\t*/\n\t__newFuture__: function __newFuture__(cancelValue) {\n\t\tvar future = this.__future__;\n\t\tif (future && future.isPending()) {\n\t\t\tif (future.hasOwnProperty('__cancelValue__')) {\n\t\t\t\tfuture.resolve(future.__cancelValue__);\n\t\t\t} else {\n\t\t\t\tfuture.reject(\"Canceled!\");\n\t\t\t}\n\t\t}\n\t\tfuture = new Future();\n\t\tif (typeof cancelValue !== 'undefined') {\n\t\t\tfuture.__cancelValue__ = cancelValue;\n\t\t}\n\t\tthis.__future__ = future;\n\t\treturn future;\n\t},\n\n\t/** The `__onemessage__` method is the handler of the webworker messages to the calling thread.\n\t*/\n\t__onmessage__: function __onmessage__(msg) {\n\t\tvar future = this.__future__;\n\t\tif (future) {\n\t\t\tif (future.hasOwnProperty('__cancelValue__')) {\n\t\t\t\tfuture.resolve(future.__cancelValue__);\n\t\t\t} else {\n\t\t\t\tfuture.reject(\"Canceled!\");\n\t\t\t}\n\t\t}\n\t\tthis.__future__ = null;\n\t\ttry {\n\t\t\tvar data = JSON.parse(msg.data);\n\t\t\tif (data.error) {\n\t\t\t\tfuture.reject(data.error);\n\t\t\t} else {\n\t\t\t\tfuture.resolve(data.result);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tfuture.reject(err);\n\t\t}\n\t},\n\n\t/** The method `__run__` executes the given `code` in the player's webworker. Returns a future\n\tthe will be fulfilled when the code execution ends. The returned future is also stored in the\n\tplayer's `__future__` property.\n\t*/\n\t__run__: function __run__(code) {\n\t\tvar future = this.__newFuture__(Match.commandQuit);\n\t\tthis.worker.postMessage(code);\n\t\treturn future;\n\t},\n\n\t/** This player's `decision` method is delegated to this player's webworker, returning a future\n\tthat will be resolved when the parallel execution is over.\n\n\tWarning! If this method is called while another decision is pending, the player will assume the\n\tprevious match was aborted, issuing a quit command.\n\t*/\n\tdecision: function decision(game, player) {\n\t\treturn this.__run__('PLAYER.decision(Sermat.mat('+ JSON.stringify(Sermat.ser(game)) +\n\t\t\t'),'+ JSON.stringify(player) +')');\n\t},\n\n\t/** This player's `evaluatedMoves` method is delegated to this player's webworker.\n\t*/\n\tevaluatedMoves: function evaluatedMoves(game, player) {\n\t\treturn this.__run__('PLAYER.evaluatedMoves(Sermat.mat('+\n\t\t\tJSON.stringify(Sermat.ser(game)) +'),'+ JSON.stringify(player) +')');\n\t}\n}); // declare WebWorkerPlayer\n","/** # TicTacToe.\n\nImplementation of the traditional [Tic-Tac-Toe game](http://en.wikipedia.org/wiki/Tictactoe).\n*/\ngames.TicTacToe = declare(Game, {\n\tname: 'TicTacToe',\n\n\t/** The constructor takes the `activePlayer` (`\"Xs\"` by default) and the `board` as a string \n\t(empty board as default).\n\t*/\n\tconstructor: function TicTacToe(activePlayer, board) {\n\t\tGame.call(this, activePlayer);\n\t\tthis.board = board || '_________';\n\t},\n\t\n\t/** This game's players are `\"Xs\"` and `\"Os\"`.\n\t*/\n\tplayers: ['Xs', 'Os'],\n\t\n\t/** A match ends with a victory for any player that has three marks in line, or a draw if the \n\tboard is full.\n\t*/\n\tresult: (function () {\n\t\treturn function result() {\t\t\t\n\t\t\tif (this.board.match(this.WIN_X)) { // Xs wins.\n\t\t\t\treturn this.victory([\"Xs\"]);\n\t\t\t} else if (this.board.match(this.WIN_O)) { // Os wins.\n\t\t\t\treturn this.victory([\"Os\"]);\n\t\t\t} else if (this.board.indexOf('_') < 0) { // No empty squares means a tie.\n\t\t\t\treturn this.tied();\n\t\t\t} else {\n\t\t\t\treturn null; // The game continues.\n\t\t\t}\n\t\t};\n\t})(),\n\t\n\t/** The active player's `moves()` are the indexes of empty squares in the board.\n\t*/\n\tmoves: function moves() {\n\t\tif (!this.result()) {\n\t\t\tvar result = {};\n\t\t\tresult[this.activePlayer()] = iterable(this.board).filter(function (chr, i) {\n\t\t\t\treturn chr === '_'; // Keep only empty squares.\n\t\t\t}, function (chr, i) {\n\t\t\t\treturn i; // Grab the index.\n\t\t\t}).toArray();\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\t\t\n\t},\n\t\n\t/** The `next` game state is calculated by putting the mark of the active player in the square \n\tindicated by the given move.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tvar activePlayer = this.activePlayer(), \n\t\t\tmove = +moves[activePlayer];\n\t\tif (isNaN(move) || this.board.charAt(move) !== '_') {\n\t\t\tthrow new Error('Invalid move '+ JSON.stringify(moves) +' for board '+ this.board +\n\t\t\t\t' (moves= '+ JSON.stringify(moves) +').');\n\t\t}\n\t\tvar nextBoard = this.board.substring(0, move) + activePlayer.charAt(0) + this.board.substring(move + 1);\n\t\tif (update) {\n\t\t\tthis.activatePlayers(this.opponent(activePlayer));\n\t\t\tthis.board = nextBoard;\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(this.opponent(activePlayer), nextBoard);\n\t\t}\n\t},\n\n\t// ## Utility methods ##########################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'TicTacToe',\n\t\tserializer: function serialize_TicTacToe(obj) {\n\t\t\treturn [obj.activePlayer(), obj.board];\n\t\t}\n\t},\n\t\n\t/** The `board` is hashed by converting it to a integer in base 3.\n\t*/\n\t__hash__: function __hash__(board) {\n\t\tvar VALUE = {'_': 0, 'X': 1, 'O': 2};\n\t\treturn parseInt((board || this.board).split('').map(function (chr) {\n\t\t\treturn VALUE[chr];\n\t\t}).join(''), 3);\n\t},\n\t\n\t/** The `equivalent` states to a game state have symmetrical or rotated (or both) boards. This\n\tmethod returns a sorted list of equivalent of boards (_strings_).\n\t\n\tThere can be 7 equivalent states for every game state. The transformations can be inspected in \n\tthe property `equivalent.MAPPINGS`.\n\t*/\n\tequivalent: (function () {\n\t\tvar MAPPINGS = '210543876 678345012 630741852 258147036 876543210 852741630 036147258'\n\t\t\t.split(' ').map(function (str) {\n\t\t\t\treturn str.split('').map(function (chr) {\n\t\t\t\t\treturn +chr;\n\t\t\t\t});\n\t\t\t}),\n\t\t\tf = function symmetricHash() {\n\t\t\t\tvar board = this.board,\n\t\t\t\t\tsyms = MAPPINGS.map(function (sym) {\n\t\t\t\t\t\treturn sym.map(function (i) {\n\t\t\t\t\t\t\treturn board.charAt(i);\n\t\t\t\t\t\t}).join('');\n\t\t\t\t\t});\n\t\t\t\tsyms.sort();\n\t\t\t\treturn syms;\n\t\t\t};\n\t\tf.MAPPINGS = MAPPINGS;\n\t\treturn f;\n\t})(),\n\t\n\t// ## User intefaces ###########################################################################\n\t\n\t/** `printBoard()` creates a text (ASCII) version of the board.\n\t*/\n\tprintBoard: function printBoard() {\n\t\tvar board = this.board;\n\t\treturn [0,3,6].map(function (i) {\n\t\t\treturn board.substr(0,3).split('').join('|');\n\t\t}).join('\\n-+-+-\\n');\n\t},\n\t\n\t// ## Heuristics and AI ########################################################################\n\t\n\t/** `TicTacToe.heuristics` is a bundle of helper functions to build heuristic evaluation \n\tfunctions for this game.\n\t*/\n\t\"static heuristics\": {\n\t\t/** `heuristicFromWeights(weights)` builds an heuristic evaluation function from weights for\n\t\teach square in the board. The result of the function is the weighted sum, empty squares \n\t\tbeing ignored, opponent squares considered negative.\n\t\t*/\n\t\theuristicFromWeights: function heuristicFromWeights(weights) {\n\t\t\tvar weightSum = iterable(weights).map(Math.abs).sum();\n\t\t\tfunction __heuristic__(game, player) {\n\t\t\t\tvar playerChar = player.charAt(0);\n\t\t\t\treturn iterable(game.board).map(function (square, i) {\n\t\t\t\t\treturn (square === '_' ? 0 : weights[i] * (square === playerChar ? 1 : -1));\n\t\t\t\t}).sum() / weightSum;\n\t\t\t}\n\t\t\t__heuristic__.weights = weights;\n\t\t\treturn __heuristic__;\n\t\t}\n\t},\n\t\n\t// ## TicTacToe type initialization ############################################################\n\t\n\t'': function () { \n\t\t/** The regular expressions `WIN_X` and `WIN_O` used in the victory test are calculated \n\t\there.\n\t\t*/\n\t\tvar board3x3 = new CheckerboardFromString(3, 3, '_'.repeat(9)),\n\t\t\tlines = board3x3.sublines(board3x3.lines(), 3);\n\t\tthis.prototype.WIN_X = new RegExp(board3x3.asRegExps(lines, 'X', '.'));\n\t\tthis.prototype.WIN_O = new RegExp(board3x3.asRegExps(lines, 'O', '.'));\n\t\t\n\t\t/** The `defaultHeuristic `for TicTacToe is based on weights for each square. Center is \n\t\tworth 5, corners 2 and the other squares 1.\n\t\t*/\n\t\tthis.heuristics.defaultHeuristic = this.heuristics\n\t\t\t.heuristicFromWeights([2,1,2,1,5,1,2,1,2]);\n\t}\t\n}); // declare TicTacToe","/** # Aleatory\n\nAleatories are different means of non determinism that games can use, like: dice, card decks,\nroulettes, etc. They are used by `Contingent` game states.\n*/\n\nvar Aleatory = exports.aleatories.Aleatory = declare({\n\t/** The base class implements a generic random variable given by a histogram or `distribution`,\n\ti.e. a list of `[value,probability]` pairs.\n\t*/\n\tconstructor: function Aleatory(distribution) {\n\t\tthis.__distribution__ = iterable(distribution).toArray();\n\t\traiseIf(this.__distribution__.length < 1, \"Aleatories must have at least one value!\");\n\t},\n\n\t/** The `count` of an aleatory is the amount of different values it can have.\n\t*/\n\tcount: function count() {\n\t\treturn this.__distribution__.length;\n\t},\n\n\t/** The `value` and `probability` methods define the aleatory variable's distribution. Both\n\ttake an index from 0 to `this.length()-1`.\n\t*/\n\tvalue: function value(i) {\n\t\treturn this.__distribution__[i][0];\n\t},\n\n\tprobability: function probability(i) {\n\t\treturn +this.__distribution__[i][1];\n\t},\n\n\t/** The `Aleatory.randomValue()` can be used to obtain a valid random value for the random\n\tvariable.\n\t*/\n\trandomValue: function randomValue(random) {\n\t\trandom = random || Randomness.DEFAULT;\n\t\treturn random.weightedChoice(this.__distribution__);\n\t},\n\n\t/** In order to properly search a game tree with aleatory nodes, the random variables'\n\tdistribution has to be known. `Aleatory.distribution()` computes the histogram for the random\n\tvariables on which this aleatory depends, as a sequence of pairs `[value, probability]`.\n\t*/\n\tdistribution: function () {\n\t\tvar alea = this;\n\t\treturn Iterable.range(this.count()).map(function (i) {\n\t\t\treturn [alea.value(i), alea.probability(i)];\n\t\t});\n\t},\n\n\t// ## Utility methods #########################################################################\n\n\t/** The `tries` function calculates the distribution of the number of successes, trying `n`\n\ttimes with a chance of `p`.\n\t*/\n\t'static tries': function tries(p, n) {\n\t\tvar combinations = base.math.combinations;\n\t\treturn n <= 0 ? [[0, 1]] : Iterable.range(n + 1).map(function (i) {\n\t\t\treturn [i, Math.pow(p, i) * Math.pow(1 - p, n - i) * combinations(n, i)];\n\t\t}).toArray();\n\t},\n\n\t/** Two `aggregate`d distributions make a new distribution with a combination of the domains. By\n\tdefault the value combination function `comb` is the sum. An equality test `eq` can be provided\n\tif the combinations cannot be compared with `===`.\n\t*/\n\t'static aggregate': function aggregate(dist1, dist2, comb, eq) {\n\t\tvar distR = [];\n\t\tcomb = comb || function (v1, v2) {\n\t\t\t\treturn v1 + v2;\n\t\t\t};\n\t\teq = eq || function (v1, v2) {\n\t\t\t\treturn v1 === v2;\n\t\t\t};\n\t\tIterable.product(dist1, dist2).forEachApply(function (p1, p2) {\n\t\t\tvar v = comb(p1[0], p2[0]);\n\t\t\tfor (var i = 0; i < distR.length; i++) {\n\t\t\t\tif (eq(distR[i][0], v)) {\n\t\t\t\t\tdistR[i][1] += p1[1] * p2[1];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdistR.push([v, p1[1] * p2[1]]);\n\t\t});\n\t\treturn distR;\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Aleatory',\n\t\tserializer: function serialize_Aleatory(obj) {\n\t\t\treturn [obj.distribution().toArray()];\n\t\t}\n\t}\n}); // declare Aleatory.\n","/** # DieAleatory\n\nAn aleatory with a uniform distribution ranging over integer values.\n*/\nvar DieAleatory = exports.aleatories.DieAleatory = declare(Aleatory, {\n\t/** A die aleatory is defined by the number of values.\n\t*/\n\tconstructor: function DieAleatory(min, max) {\n\t\tif (arguments.length === 1) {\n\t\t\tmax = min;\n\t\t\tmin = 1;\n\t\t}\n\t\tthis.min = min |0;\n\t\tthis.max = max |0;\n\t},\n\n\t/** The methods of `Aleatory` have been optimized for this particular case.\n\t*/\n\tcount: function count() {\n\t\treturn this.max - this.min + 1;\n\t},\n\n\tvalue: function value(i) {\n\t\treturn i > (this.max - this.min) ? undefined : i + this.min;\n\t},\n\n\tprobability: function probability(i) {\n\t\treturn i > (this.max - this.min) ? NaN : 1 / (this.max - this.min + 1);\n\t},\n\n\trandomValue: function randomValue(random) {\n\t\treturn (random || Randomness.DEFAULT).randomInt(this.min, this.max + 1);\n\t},\n\n\t// ## Utilities ###############################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'DiceAleatory',\n\t\tserializer: function serialize_DiceAleatory(obj) {\n\t\t\treturn [obj.min, obj.max];\n\t\t}\n\t}\n});\n\n// ## Common dice variants #########################################################################\n\naleatories.dice = {\n\tD4: new DieAleatory(4),\n\tD6: new DieAleatory(6),\n\tD8: new DieAleatory(8),\n\tD10: new DieAleatory(10),\n\tD12: new DieAleatory(12),\n\tD20: new DieAleatory(20)\n};\n","// See __prologue__.js\n\t[Match,\n\t// Games.\n\t\tgames.Bahab, games.Choose2Win, games.ConnectionGame, games.Mutropas, games.OddsAndEvens,\n\t\t\tgames.Pig, games.Predefined, games.TicTacToe, games.ToadsAndFrogs, games.Puzzle15,\n\t// Players.\n\t\tPlayer, players.AlphaBetaPlayer, players.MaxNPlayer, players.MiniMaxPlayer,\n\t\t\tplayers.MonteCarloPlayer, players.RandomPlayer, players.TracePlayer, players.UCTPlayer,\n\t// Tournaments.\n\t\tTournament, tournaments.Elimination, tournaments.Measurement, tournaments.RoundRobin,\n\t// Aleatories.\n\t\taleatories.Aleatory, aleatories.DieAleatory,\n\t// Utilities.\n\t\tutils.CheckerboardFromString\n\t].forEach(function (type) {\n\t\ttype.__SERMAT__.identifier = exports.__package__ +'.'+ type.__SERMAT__.identifier;\n\t\texports.__SERMAT__.include.push(type);\n\t});\n\tSermat.include(exports); // Ludorum uses Sermat internally.\n\n\treturn exports;\n}\n","/** # Dice aleatories\n\nImplementations of common dice and related functions.\n*/\n\n/** An uniform aleatory is a usual case, where each value in the range of the random variable has\nthe same probability.\n*/\naleatories.uniformAleatory = function uniformAleatory(values) {\n\tvalues = iterable(values).toArray();\n\tvar probability = 1 / values.length;\n\treturn new Aleatory(values.map(function (value) {\n\t\treturn [value, probability];\n\t}));\n};\n\n/** The `normalization` of a distribution forces all probabilities to add up to one.\n*/\naleatories.normalization = function normalization(distribution) {\n\tvar probSum = 0,\n\t\tresult = [];\n\titerable(distribution).forEachApply(function (v, p) {\n\t\traiseIf(p < 0, \"aleatories.normalization: probabilities cannot be negative (\"+ p +\")!\");\n\t\tprobSum += p;\n\t\tfor (var i = 0; i < result.length; i++) {\n\t\t\tif (result[i][0] === v) {\n\t\t\t\tresult[i][1] += p;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tresult.push([v, p]);\n\t});\n\tif (probSum > 0) {\n\t\tresult.forEach(function (t) {\n\t\t\tt[1] /= probSum;\n\t\t});\n\t}\n\treturn result;\n};\n\n/** The `sumProbability` that rolling `n` dice of `s` sides yields a sum equal to `p`. Check the\narticle at [Mathworld](http://mathworld.wolfram.com/Dice.html).\n*/\naleatories.sumProbability = function sumProbability(p, n, s) {\n\tn = n|0;\n\ts = s|0;\n\tp = p|0;\n\tif (isNaN(n) || isNaN(s) || isNaN(p) || n < 1 || s < 2) {\n\t\treturn NaN;\n\t} else if (p < n || p > n * s) {\n\t\treturn 0;\n\t} else {\n\t\tvar factorial = base.math.factorial,\n\t\t\tfact_n = factorial(n),\n\t\t\tfact_n_1 = fact_n / n; // factorial(n - 1)\n\t\treturn Math.pow(s, -n) *\n\t\t\tIterable.range(0, Math.floor((p - n) / s) + 1).map(function (k) {\n\t\t\t\tvar comb1 = fact_n / factorial(k) / factorial(n - k),\n\t\t\t\t\tx = p - s * k - 1,\n\t\t\t\t\tcomb2 = factorial(x) / fact_n_1 / factorial(x - n + 1);\n\t\t\t\treturn (k % 2 ? -1 : 1) * comb1 * comb2;\n\t\t\t}).sum();\n\t}\n};\n","/** # Predefined\n\nSimple reference games with a predefined outcome, mostly for testing purposes.\n*/\ngames.Predefined = declare(Game, {\n\tname: 'Predefined',\n\theight: 5,\n\twidth: 5,\n\t\n\t/** `Predefined` is a pseudogame used for testing purposes. It will give `width` amount of \n\tmoves for each player until `height` moves pass. Then the match is finished with the given \n\t`results`, or a tie as default.\n\t*/\n\tconstructor: function Predefined(activePlayer, results, height, width) {\n\t\tif (results) {\n\t\t\tthis.__results__ = results;\n\t\t\tthis.players = Object.keys(results);\n\t\t}\n\t\tGame.call(this, activePlayer);\n\t\tif (!isNaN(height)) {\n\t\t\tthis.height = +height;\n\t\t}\n\t\tif (!isNaN(width)) {\n\t\t\tthis.width = +width;\n\t\t}\n\t},\n\t\n\t/** Default players for `Predefined`: A and B.\n\t*/\n\tplayers: ['A', 'B'],\n\n\t/** Default results for Predefined: a tie between A and B.\n\t*/\n\t__results__: {'A': 0, 'B': 0},\n\n\t/** Moves for a `Predefined` are numbers from 1 to this.width. \n\t*/\n\tmoves: function moves() {\n\t\tif (this.height > 0) {\n\t\t\treturn obj(this.activePlayer(), \n\t\t\t\tIterable.range(1, this.width + 1).toArray()\n\t\t\t);\n\t\t}\n\t},\n\n\t/** Returned the predefined results if height is zero or less.\n\t*/\n\tresult: function result() {\n\t\treturn this.height > 0 ? null : this.__results__;\n\t},\n\n\t/** Moves are completely irrelevant. They only advance in the match.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tif (update) {\n\t\t\tthis.height--;\n\t\t\tthis.activatePlayers(this.opponent());\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(this.opponent(), this.__results__, this.height - 1, this.width);\n\t\t}\n\t},\n\t\n\t// ## Utility methods ##########################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Predefined',\n\t\tserializer: function serialize_Predefined(obj) {\n\t\t\treturn [obj.activePlayer(), obj.__results__, obj.height, obj.width];\n\t\t}\n\t}\n}); // declare Predefined.\n","/** # Choose2Win\n\nChoose2Win is a simple silly game. Each turn one of the players can decide to win, to lose or to \npass the turn. It is meant to be used only for testing Ludorum, since a game can hardly become less \ninteresting than this.\n*/\ngames.Choose2Win = declare(Game, {\n\t/** The constructor takes a number of turns for the game to last (`Infinity` by default), the \n\tactive player and the winner if the game has ended. \n\t*/\n\tconstructor: function Choose2Win(turns, activePlayer, winner) {\n\t\tGame.call(this, activePlayer);\n\t\tthis.__turns__ = isNaN(turns) ? Infinity : +turns;\n\t\tthis.__winner__ = winner;\t\t\n\t},\n\n\tname: 'Choose2Win',\n\t\n\t/** Players of this dummy game are labeled This and That.\n\t*/\n\tplayers: ['This', 'That'],\n\n\t/** Every turn the active player's moves are: `'win'`, `'lose'` and `'pass'`.\n\t*/\n\tmoves: function moves() {\n\t\tif (!this.__winner__ && this.__turns__ > 0) {\n\t\t\treturn obj(this.activePlayer(), ['win', 'lose', 'pass']);\n\t\t}\n\t},\n\n\t/** Victory is for whom chooses to win first. Defeat is for whom chooses to lose first. A draw \n\tonly results when the limit of turns (if any) is met.\n\t*/\n\tresult: function result() {\n\t\treturn this.__winner__ ? this.victory(this.__winner__) :\n\t\t\tthis.__turns__ < 1 ? this.draw() : null;\n\t},\n\n\t/** If a player moves to win or lose, a final game state is returned. Else the game goes on.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\topponent = this.opponent(activePlayer);\n\t\traiseIf(!moves.hasOwnProperty(activePlayer), \n\t\t\t'No move for active player ', activePlayer, ' at ', this, '!');\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tvar winner = { win: activePlayer, lose: opponent, pass: undefined },\n\t\t\tmove = moves[activePlayer];\n\t\tif (!winner.hasOwnProperty(move)) {\n\t\t\traise('Invalid move ', moves[activePlayer], ' for ', activePlayer, ' at ', this, '!');\n\t\t} else if (update) {\n\t\t\tthis.activatePlayers(opponent);\n\t\t\tthis.__turns__--;\n\t\t\tthis.__winner__ = winner[move];\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(this.__turns__ - 1, opponent, winner[move]);\n\t\t}\n\t},\n\t\n\t// ## Utilities ################################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Choose2Win',\n\t\tserializer: function serialize_Choose2Win(obj) {\n\t\t\tvar r = [obj.__turns__, obj.activePlayer()];\n\t\t\tif (obj.__winner__) {\n\t\t\t\tr.push(obj.__winner__);\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t}\n}); // declare Choose2Win.","/** # ConnectionGame\n\nBase class for a subset of the family of [connection games](http://en.wikipedia.org/wiki/Connection_game), \nwhich includes [TicTacToe](http://en.wikipedia.org/wiki/Tic-tac-toe), \n[ConnectFour](http://en.wikipedia.org/wiki/Connect_Four) and [Gomoku](http://en.wikipedia.org/wiki/Gomoku).\nIt implements a rectangular board, the placing of the pieces and the checks for lines.\n*/\ngames.ConnectionGame = declare(Game, {\n\tname: 'ConnectionGame',\n\n\t/** Boards by default have 9 rows ...\n\t*/\n\theight: 9,\n\t\n\t/** ... and 9 columns.\n\t*/\n\twidth: 9,\n\t\n\t/** A player has to make a line of 5 pieces to win, by default.\n\t*/\n\tlineLength: 5,\n\n\t/** The constructor takes the active player and the board given as a string. For the game's \n\t`board` this last string argument is used to build a [`CheckerboardFromString`](../utils/CheckerboardFromString.js.html).\n\t*/\n\tconstructor: function ConnectionGame(activePlayer, board) {\n\t\tGame.call(this, activePlayer);\n\t\tthis.board = (board instanceof CheckerboardFromString) ? board : \n\t\t\tnew CheckerboardFromString(this.height, this.width, board);\n\t\tthis.height = this.board.height;\n\t\tthis.width = this.board.width;\n\t},\n\t\n\t/** This base implementations names its players First and Second.\n\t*/\n\tplayers: ['First', 'Second'],\n\t\n\t/** Lines in the board are cached to accelerate the result calculation. */\n\t__lines__: (function () {\n\t\tvar CACHE = {};\n\t\tfunction __lines__(height, width, lineLength) {\n\t\t\tvar key = height +'x'+ width +'/'+ lineLength;\n\t\t\tif (!CACHE.hasOwnProperty(key)) {\n\t\t\t\tvar board = new CheckerboardFromString(height, width, '.'.repeat(height * width));\n\t\t\t\tCACHE[key] = board.lines().map(function (line) {\n\t\t\t\t\treturn line.toArray();\n\t\t\t\t}, function (line) {\n\t\t\t\t\treturn line.length >= lineLength;\n\t\t\t\t}).toArray();\n\t\t\t}\n\t\t\treturn CACHE[key];\n\t\t}\n\t\t__lines__.CACHE = CACHE;\n\t\treturn __lines__;\n\t})(),\n\t\n\t/** A connection game ends when either player gets the required amount of pieces aligned (either\n\thorizontally, vertically or diagonally), hence winning the game. The match ends in a tie if the \n\tboard gets full.\n\t*/\n\tresult: function result() {\n\t\tif (this.hasOwnProperty('__result__')) {\n\t\t\treturn this.__result__;\n\t\t}\n\t\tvar lineLength = this.lineLength,\n\t\t\tlines = this.board.asStrings(this.__lines__(this.height, this.width, lineLength)).join(' ');\n\t\tfor (var i = 0; i < this.players.length; ++i) {\n\t\t\tif (lines.indexOf(i.toString(36).repeat(lineLength)) >= 0) {\n\t\t\t\treturn this.__result__ = this.victory([this.players[i]]);\n\t\t\t}\n\t\t}\n\t\tif (lines.indexOf('.') < 0) { // No empty squares means a tie.\n\t\t\treturn this.__result__ = this.tied();\n\t\t}\n\t\treturn this.__result__ = null; // The game continues.\n\t},\n\t\n\t/** The active player can place a piece in any empty square in the board. The moves are indices\n\tin the board's string representation.\n\t*/\n\tmoves: function moves() {\n\t\tif (this.hasOwnProperty('__moves__')) {\n\t\t\treturn this.__moves__;\n\t\t} else if (this.result()) {\n\t\t\tthis.__moves__ = null;\n\t\t} else {\n\t\t\tvar board = this.board;\n\t\t\tthis.__moves__ = obj(this.activePlayer(),\n\t\t\t\tboard.coordinates().filter(function (coord) {\n\t\t\t\t\treturn board.isEmptySquare(coord);\n\t\t\t\t}).toArray()\n\t\t\t);\n\t\t}\n\t\treturn this.__moves__;\n\t},\n\n\t/** To get from one game state to the next, an active player's piece in the square indicated by \n\tits move.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, \"Haps are not required (given \", haps, \")!\");\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tplayerIndex = this.players.indexOf(activePlayer),\n\t\t\tcoord = moves[activePlayer],\n\t\t\tnextPlayer = (playerIndex + 1) % this.players.length,\n\t\t\tnextBoard = this.board.place(coord, playerIndex.toString(36));\n\t\tif (update) {\n\t\t\tthis.activatePlayers(nextPlayer);\n\t\t\tthis.board = nextBoard;\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(nextPlayer, nextBoard);\n\t\t}\n\t},\n\t\n\t// ## User intefaces ###########################################################################\n\t\n\t/** The `display(ui)` method is called by a `UserInterface` to render the game state. The only \n\tsupported user interface type is `BasicHTMLInterface`. The look can be configured using CSS \n\tclasses.\n\t*/\n\tdisplay: function display(ui) {\n\t\traiseIf(!ui || !(ui instanceof UserInterface.BasicHTMLInterface), \"Unsupported UI!\");\n\t\tvar moves = this.moves(),\n\t\t\tactivePlayer = this.activePlayer(),\n\t\t\tboard = this.board;\n\t\tmoves = moves && moves[activePlayer];\n\t\tvar table = this.board.renderAsHTMLTable(ui.document, ui.container, function (data) {\n\t\t\t\tdata.className = data.square === '.' ? 'ludorum-empty' : 'ludorum-player'+ data.square;\n\t\t\t\tdata.innerHTML = data.square === '.' ? \"&nbsp;\" : \"&#x25CF;\";\n\t\t\t\tvar i = data.coord[0] * board.height + data.coord[1];\n\t\t\t\tif (moves && moves.indexOf(i) >= 0) {\n\t\t\t\t\tdata.move = i;\n\t\t\t\t\tdata.activePlayer = activePlayer;\n\t\t\t\t\tdata.onclick = ui.perform.bind(ui, data.move, activePlayer);\n\t\t\t\t}\n\t\t\t});\n\t\treturn ui;\n\t},\n\n\t// ## Utilities ################################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'ConnectionGame',\n\t\tserializer: function serialize_ConnectionGame(obj) {\n\t\t\treturn [obj.activePlayer(), obj.board];\n\t\t}\n\t}\n}); // declare ConnectionGame.","/** # Odds & Evens\n\n[Odds and evens](http://en.wikipedia.org/wiki/Odds_and_evens) is a classic child game, implemented \nas a simple example of a simultaneous game, i.e. a game in which more than one player can move at \nany given turn.\n*/\ngames.OddsAndEvens = declare(Game, {\n\tname: 'OddsAndEvens',\n\t\n\t/** The constructor takes:\n\t\t+ `turns=1`: The number of turns remaining in the game.\n\t\t+ `points=<zero for every player>`: The scores for every player.\n\t*/\n\tconstructor: function OddsAndEvens(turns, points) {\n\t\tGame.call(this, this.players); // Both players are active.\n\t\tthis.turns = isNaN(turns) ? 1 : +turns;\n\t\tthis.points = points || { Evens: 0, Odds: 0 };\n\t},\n\t\n\t/** Odds and evens is a simple exemplar of a simultaneous game.\n\t*/\n\tisSimultaneous: true,\n\t\n\t/** Players for odds and evens are called like that: Evens and Odds.\n\t*/\n\tplayers: ['Evens', 'Odds'],\n\n\t/** Each turn both players draw either a 1 or a 2.\n\t*/\n\tmoves: function moves() {\n\t\treturn this.turns < 1 ? null : { Evens: [1, 2], Odds: [1, 2] };\n\t},\n\n\t/** The winner is the player with more points.\n\t*/\n\tresult: function result() {\n\t\tvar pointDifference = this.points.Evens - this.points.Odds;\n\t\treturn this.turns > 0 ? null : {\n\t\t\tEvens: +pointDifference,\n\t\t\tOdds: -pointDifference\n\t\t};\n\t},\n\n\t/** The player matching the parity of the moves sum earns a point.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(typeof moves.Evens !== 'number' || typeof moves.Odds !== 'number',\n\t\t\t\"Invalid moves \", moves, \"!\");\n\t\traiseIf(haps, \"Haps are not required (given \", haps, \")!\");\n\t\tvar parity = (moves.Evens + moves.Odds) % 2 === 0,\n\t\t\tpoints = {\n\t\t\t\tEvens: this.points.Evens + (parity ? 1 : 0),\n\t\t\t\tOdds: this.points.Odds + (parity ? 0 : 1)\n\t\t\t};\n\t\tif (update) {\n\t\t\tthis.turns--;\n\t\t\tthis.points = points;\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(this.turns - 1, points);\n\t\t}\n\t},\n\n\t// ## Utility methods ##########################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'OddsAndEvens',\n\t\tserializer: function serialize_OddsAndEvens(obj) {\n\t\t\treturn [obj.turns, obj.points];\n\t\t}\n\t}\n}); // declare OddsAndEvens.\n","/** # ToadsAndFrogs\n\nImplementation of the [Toads & Frogs](http://en.wikipedia.org/wiki/Toads_and_Frogs_%28game%29) game.\n*/\ngames.ToadsAndFrogs = declare(Game, {\n\tname: 'ToadsAndFrogs',\n\t\n\t/** Constructor of Toads & Frogs games. The first player is always _Toads_. The default board is\n\t`'TTT__FFF'`.\n\t*/\n\tconstructor: function ToadsAndFrogs(activePlayer, board) {\n\t\tGame.call(this, activePlayer);\n\t\tthis.board = board || ToadsAndFrogs.board();\n\t},\n\t\n\t/** A `board` builder for Toads & Frogs. These boards are single rows with a given number of \n\t`chips` for each player (toads to the left and frogs to the right) separated by the given number \n\tof empty spaces (`separation`).\n\t*/\n\t\"static board\": function board(chips, separation) {\n\t\tchips = isNaN(chips) ? 3 : +chips;\n\t\tseparation = isNaN(separation) ? 2 : +separation;\n\t\treturn 'T'.repeat(chips) + '_'.repeat(separation) + 'F'.repeat(chips);\n\t},\n\t\n\t/** There are two roles in this game: _Toads_ and _Frogs_.\n\t*/\n\tplayers: ['Toads', 'Frogs'],\n\t\n\t/** The match finishes when one player cannot move, hence losing the game.\n\t*/\n\tresult: function result() {\n\t\treturn this.moves() ? null : this.defeat();\n\t},\n\t\n\t/** The active players `moves` is a list of square indexes (integers) in the board, where chips\n\tcan be moved in one of the two ways possible in this game.\n\t*/\n\tmoves: function moves() {\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tresult = {}, \n\t\t\tms = result[activePlayer] = [];\n\t\tthis.board.replace(activePlayer == this.players[0] ? /TF?_/g : /_T?F/g, function (m, i) {\n\t\t\tms.push(i);\n\t\t\treturn m;\n\t\t});\n\t\treturn ms.length > 0 ? result : null;\n\t},\n\t\n\t/** The board of the next game state is calculated by applying the given move.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tvar activePlayer = this.activePlayer(), \n\t\t\tmove = moves[activePlayer], \n\t\t\tchip = activePlayer.charAt(0),\n\t\t\tboard = this.board,\n\t\t\tnextBoard;\n\t\tif (board.substr(move, 2) == 'T_') {\n\t\t\tnextBoard = board.substring(0, move) + '_T' + board.substring(move + 2);\n\t\t} else if (board.substr(move, 2) == '_F') {\n\t\t\tnextBoard = board.substring(0, move) + 'F_' + board.substring(move + 2);\n\t\t} else if (board.substr(move, 3) == 'TF_') {\n\t\t\tnextBoard = board.substring(0, move) + '_FT' + board.substring(move + 3);\n\t\t} else if (board.substr(move, 3) == '_TF') {\n\t\t\tnextBoard = board.substring(0, move) + 'FT_' + board.substring(move + 3);\n\t\t} else {\n\t\t\tthrow new Error('Invalid move ', move, ' for board <', board, '>.');\n\t\t}\n\t\tif (update) {\n\t\t\tthis.activatePlayers(this.opponent());\n\t\t\tthis.board = nextBoard;\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(this.opponent(), nextBoard);\n\t\t}\n\t},\n\n\t// ## Utility methods ##########################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'ToadsAndFrogs',\n\t\tserializer: function serialize_ToadsAndFrogs(obj) {\n\t\t\treturn [obj.activePlayer(), obj.board];\n\t\t}\n\t},\n\t\n\t/** The game state is hashed by converting the concatenation of the `activePlayer` and the \n\t`board` it to a integer in base 3.\n\t*/\n\t__hash__: function __hash__(activePlayer, board) {\n\t\tvar VALUE = {'_': 0, 'T': 1, 'F': 2};\n\t\tactivePlayer = (activePlayer || this.activePlayer()).charAt(0);\n\t\tboard = board || this.board;\n\t\treturn parseInt((activePlayer + board).split('').map(function (chr) {\n\t\t\treturn VALUE[chr];\n\t\t}).join(''), 3);\n\t}\n}); // declare ToadsAndFrogs\n","/** # Pig.\n\n[Pig](http://en.wikipedia.org/wiki/Pig_%28dice_game%29) is a simple dice betting game, used as an \nexample of a game with random variables.\n*/\ngames.Pig = declare(Game, {\n\tname: 'Pig',\n\t\n\t/** The constructor takes:\n\t\n\t\t+ `activePlayer='One'`: The active player.\n\t\t+ `goal=100`: The amount of points a player has to reach to win the game.\n\t\t+ `scores`: The scores so far in the match.\n\t\t+ `rolls`: The rolls the active player has made in his turn.\n\t*/\n\tconstructor: function Pig(activePlayer, goal, scores, rolls) {\n\t\tGame.call(this, activePlayer);\n\t\tthis.goal = isNaN(goal) ? 100 : +goal;\n\t\tthis.__scores__ = scores || iterable(this.players).zip([0, 0]).toObject();\n\t\tthis.__rolls__ = rolls || [];\n\t},\n\t\n\t/** Since it involves dice, Pig is not a deterministic game. \n\t*/\n\tisDeterministic: false,\n\t\n\t/** Players for Pig are named `One`, `Two`.\n\t*/\n\tplayers: ['One', 'Two'],\n\n\t/** The active player can either hold and pass the turn, or roll.\n\t*/\n\tmoves: function moves() {\n\t\tif (!this.result()) {\n\t\t\tvar activePlayer = this.activePlayer(),\n\t\t\t\tcurrentScore = this.__scores__[activePlayer] + iterable(this.__rolls__).sum();\n\t\t\treturn obj(activePlayer, this.__rolls__.length < 1 ? ['roll'] :\n\t\t\t\tcurrentScore >= this.goal ? ['hold'] : ['roll', 'hold']);\n\t\t}\n\t},\n\n\t/** A Pig match finishes when one player reaches or passes the goal score. The result for each \n\tplayer is the difference between its score and its opponent's score.\n\t*/\n\tresult: function result() {\n\t\tvar score0 = this.__scores__[this.players[0]],\n\t\t\tscore1 = this.__scores__[this.players[1]];\n\t\tif (score0 >= this.goal || score1 >= this.goal) {\n\t\t\tvar r = {};\n\t\t\tr[this.players[0]] = Math.min(this.goal, score0) - Math.min(this.goal, score1);\n\t\t\tr[this.players[1]] = -r[this.players[0]];\n\t\t\treturn r;\n\t\t}\n\t},\n\n\t/** If the active player holds, it earns the sum of the rolls made so in its turn. If the move \n\tis roll, a die is rolled. A roll of 1 stops the this turn and the active player earns no \n\tpoints. A roll of 2 or up, makes the turn continue.\n\t\n\tFor this game mechanic, an [contingent game state](../Contingent.js.html) is used. If the move \n\tis `roll`, an instance of this class is build and returned using the [dice shotcuts](\n\t../aleatories/dice.js.html) as random variables. This aleatoric game state will call the `next` \n\tmethod again with the same moves and the values of the random variables, and then the match will\n\tcontinue.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tmove = moves && moves[activePlayer];\n\t\traiseIf(!move, 'No move for active player ', activePlayer, ' at ', this, '!');\n\t\tvar nextPlayer = this.opponent(),\n\t\t\tnextScores = this.__scores__,\n\t\t\tnextRolls = [];\n\t\tif (move === 'hold' || move === 'roll') {\n\t\t\tif (move === 'hold') {\n\t\t\t\tnextScores = copy(nextScores);\n\t\t\t\tnextScores[activePlayer] += iterable(this.__rolls__).sum();\n\t\t\t} else { // if (move === 'roll') {\n\t\t\t\tvar roll = (haps && haps.die)|0;\n\t\t\t\tif (!roll) { // Dice has not been rolled.\n\t\t\t\t\treturn new Contingent(this, moves, { die: aleatories.dice.D6 }, update);\n\t\t\t\t} else if (roll > 1) { // Dice has been rolled.\n\t\t\t\t\tnextPlayer = activePlayer;\n\t\t\t\t\tnextRolls = this.__rolls__.concat(roll);\n\t\t\t\t\treturn new this.constructor(activePlayer,  this.goal, this.__scores__, this.__rolls__.concat(roll));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (update) {\n\t\t\t\tthis.activatePlayers(nextPlayer);\n\t\t\t\tthis.__scores__ = nextScores;\n\t\t\t\tthis.__rolls__ = nextRolls;\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\treturn new this.constructor(nextPlayer, this.goal, nextScores, nextRolls);\n\t\t\t}\n\t\t} else {\n\t\t\traise(\"Invalid moves \", JSON.stringify(moves), \" at \", this, \"!\");\n\t\t}\n\t},\n\t\n\t// ## Utility methods ##########################################################################\n\n\t/** The `resultBounds` for a Pig game are estimated with the goals.\n\t*/\n\tresultBounds: function resultBounds() {\n\t\treturn [-this.goal, +this.goal];\n\t},\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Pig',\n\t\tserializer: function serialize_Pig(obj) {\n\t\t\treturn [obj.activePlayer(), obj.goal, obj.__scores__, obj.__rolls__];\n\t\t}\n\t}\n}); // Pig.\n","/** # Mutropas\n\nMutropas is a game invented for Ludorum as a simple example of a game of hidden (a.k.a. incomplete)\ninformation. It is also a simultaneous game.\n*/\ngames.Mutropas = declare(Game, {\n\tname: 'Mutropas',\n\t\n\t/** The players' roles are `\"Left\"` and `\"Right\"`.\n\t*/\n\tplayers: ['Left', 'Right'],\n\n\t/** The constructor takes an `args` object with:\n\t\n\t+ `pieces`: an object with the available pieces for each player. By default pieces get randomly\n\tdealt.\n\t\n\t+ `scores`: an object with current score for each player (0 by default for all players).\n\t\n\t+ `random`: the pseudorandom number generator to use (`base.Randomness.DEFAULT` by default).\n\t*/\n\tconstructor: function Mutropas(args) {\n\t\tGame.call(this, this.players);\n\t\targs = args || {};\n\t\tthis.playedPieces = args.playedPieces || [];\n\t\tthis.pieces = args.pieces || this.dealPieces(args.random);\n\t\tthis.__scores__ = args.scores || obj(this.players[0], 0, this.players[1], 0);\n\t},\n\t\n\t/** Mutropas was invented to be an example of a simultaneous non-deterministic game.\n\t*/\n\tisDeterministic: false,\n\tisSimultaneous: true,\n\t\n\t/** All the pieces to be used in a match of Mutropas are stored in `allPieces`, which by default\n\thas the numbers from 0 to 8.\n\t*/\n\tallPieces: Iterable.range(9).toArray(),\t\n\t\n\t/** The method `dealPieces` is used to split the pieces randomly between all players. Half the\n\tpieces go to each player, and one is left out.\n\t*/\n\tdealPieces: function dealPieces(random) {\n\t\trandom = random || Randomness.DEFAULT;\n\t\tvar piecesPerPlayer = (this.allPieces.length / 2)|0,\n\t\t\tsplit1 = random.split(piecesPerPlayer, this.allPieces),\n\t\t\tsplit2 = random.split(piecesPerPlayer, split1[1]);\n\t\treturn obj(this.players[0], split1[0], this.players[1], split2[0]);\n\t},\n\t\n\t/** Mutropas is a simultaneous game. Hence every turn all players can move. The moves are the\n\tpieces of each player that have not been played.\n\t*/\n\tmoves: function moves() {\n\t\treturn this.result() ? null : copy({}, this.pieces);\n\t},\n\t\n\t/** If all pieces are put in a circle, each piece beats half the pieces next to it, and it is \n\tbeaten by half the pieces before it. For example if `allPieces` where `[0,1,2,3,4]`:\n\t\n\t+ piece `1` would beat pieces `2` and `3`, and lose against `4` and `0`,\n\t+ piece `2` would beat pieces `3` and `4`, and lose against `0` and `1`,\n\t+ piece `4` would beat pieces `0` and `1`, and lose against `2` and `3`,\n\t\n\tThe `moveResult` returns 1 if `piece1` beats `piece2` or -1 if otherwise.\n\t*/\n\tmoveResult: function moveResult(piece1, piece2) {\n\t\tvar upperBound = iterable(this.allPieces).max(0) + 1;\n\t\tif (piece1 < piece2) {\n\t\t\treturn piece2 - piece1 <= (upperBound / 2) ? 1 : -1;\n\t\t} else if (piece1 > piece2) {\n\t\t\treturn piece1 - piece2 >= (upperBound / 2) + 1 ? 1 : -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t},\n\t\n\t/** Each turn all players play a piece, and the player who plays the greatest piece wins a \n\tpoint.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\tvar player0 = this.players[0],\n\t\t\tplayer1 = this.players[1];\n\t\tif (!this.pieces[player0] || !this.pieces[player1]) { // This state is a view.\n\t\t\treturn this.__viewNext__(moves, haps, update);\n\t\t}\n\t\tvar move0 = moves[player0],\n\t\t\tmove1 = moves[player1],\n\t\t\tpieces = this.pieces;\n\t\traiseIf(pieces[player0].indexOf(move0) < 0, \"Invalid move \", JSON.stringify(move0),\n\t\t\t\" for player \", player0, \"! (moves= \", JSON.stringify(moves), \")\");\n\t\traiseIf(pieces[player1].indexOf(move1) < 0, \"Invalid move \", JSON.stringify(move1),\n\t\t\t\" for player \", player1, \"! (moves= \", JSON.stringify(moves), \")\");\n\t\tvar moveResult = this.moveResult(move0, move1),\n\t\t\tnextPlayedPieces = this.playedPieces.concat([move0, move1]),\n\t\t\tnextPieces = obj(\n\t\t\t\tplayer0, pieces[player0].filter(function (p) { \n\t\t\t\t\treturn p !== move0; \n\t\t\t\t}), \n\t\t\t\tplayer1, pieces[player1].filter(function (p) { \n\t\t\t\t\treturn p !== move1;\n\t\t\t\t})\n\t\t\t),\n\t\t\tnextScores = obj(player0, this.__scores__[player0] + moveResult,\n\t\t\t\tplayer1, this.__scores__[player1] - moveResult);\n\t\tif (update) {\n\t\t\tthis.playedPieces = nextPlayedPieces;\n\t\t\tthis.pieces = nextPieces;\n\t\t\tthis.__scores__ = nextScores;\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor({\n\t\t\t\tplayedPieces: nextPlayedPieces,\n\t\t\t\tpieces: nextPieces,\n\t\t\t\tscores: nextScores\n\t\t\t});\n\t\t}\n\t},\n\t\n\t__viewNext__: function __viewNext__(moves, haps, update) {\n\t\tvar player = this.pieces[this.players[0]] ? this.players[0] : this.players[1],\n\t\t\topponent = this.opponent(player);\n\t\tif (!haps) {\n\t\t\treturn this.contingent(moves, \n\t\t\t\tobj(player, aleatories.uniformAleatory(this.__possiblePieces__(opponent))), \n\t\t\t\tupdate);\n\t\t} else {\n\t\t\treturn (new this.constructor({\n\t\t\t\tpieces: obj(player, this.pieces[player], opponent, haps[opponent]), \n\t\t\t\tplayedPieces: this.playedPieces,\n\t\t\t\tscores: this.__scores__\n\t\t\t})).next(moves, null, update);\n\t\t}\n\t},\n\n\t/** The game's `score` is simply the sum of the move results for each player.\n\t*/\n\tscores: function scores() {\n\t\treturn copy({}, this.__scores__);\n\t},\n\t\n\t/** A game of Mutropas ends when the players have no more pieces to play. The result is the \n\tdifference in scores.\n\t*/\n\tresult: function result() {\n\t\tvar players = this.players;\n\t\tif (this.playedPieces.length >= this.allPieces.length - 1) {\n\t\t\tvar scores = this.scores();\n\t\t\treturn this.zerosumResult(scores[players[0]] - scores[players[1]], players[0]);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\t\n\t// ## Game views ###############################################################################\n\t\n\t/** The method `__possiblePieces__` calculates the pieces the `player` may have.\n\t*/\n\t__possiblePieces__: function __possiblePieces__(player) {\n\t\tvar playedPieces = this.playedPieces,\n\t\t\topponentPieces = this.pieces[this.opponent(player)],\n\t\t\tpossiblePieces = iterable(this.allPieces).filter(function (p) {\n\t\t\t\treturn playedPieces.indexOf(p) < 0 && // p has not been played yet ...\n\t\t\t\t\topponentPieces.indexOf(p) < 0; // ... and the opponent does not have it.\n\t\t\t});\n\t\treturn possiblePieces.combinations(possiblePieces.count() - 1);\n\t},\n\t\n\t/** In this view of the game the hidden information is modelled as random variables. The \n\taleatory that is returned ranges over all possible piece sets that the opponent of the given\n\t`player` may have. After each possibility the assumption is maintained for the rest of the\n\tgame.\n\t\n\tThis allows to model the uncertainty that each player has about its opponent's pieces. By doing\n\tso an artificial player that searches the game space cannot infer the pieces the opponent has,\n\tand hence it cannot cheat.\n\t*/\t\n\tview: function view(player) {\n\t\treturn new this.constructor({\n\t\t\tpieces: obj(player, this.pieces[player]), \n\t\t\tplayedPieces: this.playedPieces,\n\t\t\tscores: this.__scores__\n\t\t});\n\t},\n\t\n\t// ## Utility methods ##########################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Mutropas',\n\t\tserializer: function serialize_Mutropas(obj) {\n\t\t\treturn [{\n\t\t\t\tpieces: obj.pieces, \n\t\t\t\tplayedPieces: obj.playedPieces,\n\t\t\t\tscores: obj.__scores__\n\t\t\t}];\n\t\t}\n\t}\n}); // declare Mutropas","/** # Bahab\n\nBahab is a chess-like board game originally designed for Ludorum.\n*/\ngames.Bahab = declare(Game, {\n\tname: 'Bahab',\n\t\n\t/** Players are `Uppercase` and `Lowercase`.\n\t*/\n\tplayers: ['Uppercase', 'Lowercase'],\n\t\n\t/** The constructor takes the `activePlayer` (Uppercase by default) and the `board` as a string \n\t(`initialBoard` by default).\n\t*/\n\tconstructor: function Bahab(activePlayer, board) {\n\t\tGame.call(this, activePlayer);\n\t\tthis.board = board instanceof CheckerboardFromString ? board\n\t\t\t: new CheckerboardFromString(5, 5, board || this.initialBoard);\n\t},\n\t\n\t/** The `initialBoard` has two ranks of pieces for each player. All B pieces except one A piece \n\tat the center of the first rank.\n\t*/\n\tinitialBoard: ['BBABB', 'BBBBB', '.....', 'bbbbb', 'bbabb'].join(''),\n\n\t/** `__PLAYER_ENDGAME_RE__` regular expressions are used to optimize result calculations. They \n\tmatch if the player has no A piece or if its opponent has an A piece in its rank.\n\t*/\n\t__PLAYER_ENDGAME_RE__: {\n\t\tUppercase: /^[.Bab]+$|^.{0,4}[a]/, \n\t\tLowercase: /^[.bAB]+$|[A].{0,4}$/ \n\t},\n\t\n\t/** A player wins when it moves its A piece to the opponent's first rank, and loses when its A \n\tpiece is captured by the opponent.\n\t*/\n\tresult: function result() {\n\t\tvar board = this.board.string, player;\n\t\tfor (var i = 0; i < 2; ++i) {\n\t\t\tplayer = this.players[i];\n\t\t\tif (board.match(this.__PLAYER_ENDGAME_RE__[player])) {\n\t\t\t\treturn this.defeat(player); \n\t\t\t}\n\t\t}\n\t\treturn this.moves() ? null : this.defeat(this.activePlayer());\n\t},\n\t\n\t/** `__PLAYER_PIECES_RE__` regular expressions are used to optimize move calculations.\n\t*/\n\t__PLAYER_PIECES_RE__: {\n\t\tUppercase: /[AB]/g,\n\t\tLowercase: /[ab]/g\n\t},\n\t\n\t/** All pieces move one square forward. Piece A can move straight backwards or diagonally \n\tforward, and B pieces move only diagonally forward. Pieces can move to any square that is empty \n\tor occupied by an opponent's piece of the same type. If the piece moves to an occupied square, \n\tit captures the piece in it.\n\t*/\n\tmoves: function moves() {\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tpieceRegExp = this.__PLAYER_PIECES_RE__[activePlayer],\n\t\t\tboard = this.board,\n\t\t\t_moves = [];\n\t\tboard.string.replace(pieceRegExp, function (piece, i) {\n\t\t\tvar coord = [(i / 5)|0, i % 5], pieceMoves;\n\t\t\tswitch (piece) {\n\t\t\t\tcase 'A': pieceMoves = [[+1,-1], [-1, 0], [+1,+1]]; break;\n\t\t\t\tcase 'B': pieceMoves = [[+1,-1], [+1,+1]]; break;\n\t\t\t\tcase 'a': pieceMoves = [[-1,-1], [+1, 0], [-1,+1]]; break;\n\t\t\t\tcase 'b': pieceMoves = [[-1,-1], [-1,+1]]; break;\n\t\t\t}\n\t\t\titerable(pieceMoves).forEachApply(function (dx, dy) {\n\t\t\t\tvar coordTo = [coord[0] + dx, coord[1] + dy],\n\t\t\t\t\tsquareTo = board.square(coordTo);\n\t\t\t\tif (board.isValidCoord(coordTo) && !squareTo.match(pieceRegExp) &&\n\t\t\t\t\t\t(squareTo == '.' || piece.toLowerCase() == squareTo.toLowerCase())) {\n\t\t\t\t\t_moves.push([coord, coordTo]); // Valid coordinate and not occupied by a friendly piece.\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn piece;\n\t\t});\n\t\treturn _moves.length > 0 ? obj(activePlayer, _moves) : null;\n\t},\n\t\n\t/** Valid move for this game are pairs of coordinates (`[row, column]`), the first one being \n\twhere the moving piece starts, and the second one being where the moving piece ends.\t\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, \"Haps are not required (given \", haps, \")!\");\n\t\traiseIf(!moves, \"Invalid moves \", moves, \"!\");\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tmove = moves[activePlayer];\n\t\traiseIf(!Array.isArray(moves[activePlayer]), \"Invalid moves \", moves, \"!\");\n\t\tvar nextBoard = this.board.move(move[0], move[1]);\n\t\tif (update) {\n\t\t\tthis.activatePlayers(this.opponent());\n\t\t\tthis.board = nextBoard;\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(this.opponent(), nextBoard);\n\t\t}\n\t},\n\t\n\t// ## Utility methods ##########################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Bahab',\n\t\tserializer: function serialize_Bahab(obj) {\n\t\t\treturn [obj.activePlayer(), obj.board];\n\t\t}\n\t}\n}); // declare Bahab.","/** # Puzzle15\n\nThe [15 puzzle](https://en.wikipedia.org/wiki/15_puzzle) is a simple sliding puzzle, that consists \nin putting a set of pieces in order by moving them to the only empty space in the frame.\n\nIt is included here as a test of the support in Ludorum for singleplayer games. The only player in \nthis game is `'Player'`.\n*/\ngames.Puzzle15 = declare(Game, {\n\tname: \"Puzzle15\",\n\tplayers: ['Player'],\n\t\n\twidth: 4,\n\theight: 4,\n\ttarget: '0123456789ABCDE ',\n\tmaxMoves: 81,\n\t\n\t/** The constructor takes a `board` or builds one at random by default.\tAlso takes a \n\t`moveNumber`, or 0 by default.\n\t*/\n\tconstructor: function Puzzle15(args) {\n\t\tGame.call(this, this.players[0]);\n\t\targs = args || {};\n\t\tthis.board = args.board || this.randomBoard();\n\t\tthis.moveNumber = args.moveNumber |0;\n\t},\n\t\n\t/** The puzzle usually starts with a `randomBoard`.\n\t*/\n\trandomBoard: function randomBoard(width, height, rng, symbols) {\n\t\twidth = (width |0) || this.width;\n\t\theight = (height |0) || this.height;\n\t\trng = rng || Randomness.DEFAULT;\n\t\tsymbols = symbols || Iterable.range(width * height - 1).map(function (n) {\n\t\t\treturn n.toString(36);\n\t\t}).join('').toUpperCase();\n\t\treturn new CheckerboardFromString(width, height, \n\t\t\trng.shuffle(' '+ symbols.substr(0, width * height - 1)).join(''), ' ');\n\t},\n\t\n\t/** The puzzle is finished when the pieces and the empty square are arranged in the `target`\n\tconfiguration.\n\t*/\n\tdifferences: function differences(target) {\n\t\ttarget = target || this.target;\n\t\tvar str = this.board.string;\n\t\treturn iterable(str).zip(target).map(function (p) {\n\t\t\treturn p[0] === p[1] ? 0 : 1;\n\t\t}).sum();\n\t},\n\t\n\t/** The score of the player is the number of remaining moves.\n\t*/\n\tscores: function scores() {\n\t\treturn obj(this.players[0], this.maxMoves - this.moveNumber);\t\n\t},\n\t\n\t/** The puzzle can only end in victory, or remain unsolved.\n\t*/\n\tresult: function result() {\n\t\treturn this.differences() === 0 ? this.victory() : \n\t\t\tthis.moveNumber >= this.maxMoves ? this.defeat() : null;\n\t},\n\t\n\t/** The moves of the player are defined by the position of the empty square.\n\t*/\n\temptyCoord: function emptyCoord() {\n\t\tvar i = this.board.string.indexOf(' '),\n\t\t\twidth = this.board.width;\n\t\treturn [(i / width) |0, i % width];\n\t},\n\t\n\t/** The player can move the empty square up, down, left or right. A move is the coordinate where\n\tto move the empty square.\n\t*/\n\tmoves: function moves() {\n\t\tvar pos = this.emptyCoord(),\n\t\t\tboard = this.board;\n\t\tif (this.result()) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn { Player: iterable(Checkerboard.DIRECTIONS.ORTHOGONAL).mapApply(function (dr, dc) {\n\t\t\t\t\treturn [pos[0] + dr, pos[1] + dc];\t\t\t\n\t\t\t\t}, this.board.isValidCoord.bind(this.board)).toArray()\n\t\t\t};\n\t\t}\n\t},\n\t\n\t/** The next game state is calculated simply by swapping the contents of the empty square and\n\tthe given position in the board.\n\t*/\n\tnext: function next(move, haps, update) {\n\t\traiseIf(haps, \"Haps are not required (given \", haps, \")!\");\n\t\tvar nextBoard = this.board.swap(this.emptyCoord(), move.Player);\n\t\tif (update) {\n\t\t\tthis.board = nextBoard;\n\t\t\tthis.moveNumber++;\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor({ board: nextBoard, moveNumber: this.moveNumber + 1 });\n\t\t}\n\t},\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Puzzle15',\n\t\tserializer: function serialize_Puzzle15(obj) {\n\t\t\treturn [{ board: obj.board, moveNumber: obj.moveNumber }];\n\t\t}\n\t}\t\n}); // declare Puzzle15","/** # RoundRobin\n\n[Round-robins](http://en.wikipedia.org/wiki/Round-robin_tournament) are \ntournaments where all players play against each other a certain number of times.\n*/\ntournaments.RoundRobin = declare(Tournament, {\n\t/** The constructor takes the `game` to be played, the `players` and the \n\tamount of matches each player should play (`matchCount`).\n\t*/\n\tconstructor: function RoundRobin(game, players, matchCount) {\n\t\tTournament.call(this, game, players);\n\t\tthis.matchCount = isNaN(matchCount) ? game.players.length : +matchCount;\n\t\tthis.__advance__ = this.__matches__().chain(Iterable.repeat(null)).__iter__();\n\t},\n\n\t/** Round-robin matches make every player plays `matchCount` matches for \n\teach role in the game against all the other opponents.\n\t*/\n\t__matches__: function __matches__() {\n\t\tvar tournament = this,\n\t\t\tgame = this.game;\n\t\treturn iterable(this.players)\n\t\t\t.permutations(game.players.length)\n\t\t\t.product(Iterable.range(this.matchCount)).map(function (tuple) {\n\t\t\t\treturn new Match(game, tuple[0]);\n\t\t\t});\n\t},\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'RoundRobin',\n\t\tserializer: function serialize_RoundRobin(obj) { //TODO Include statistics.\n\t\t\treturn [obj.game, obj.players, obj.matchCount];\n\t\t}\n\t}\n}); //// declare RoundRobin.\n","/** # Measurement\n\nMeasurement tournaments pit the player being measured against others in order\nto assess that player's performance at a game. They are used to evaluate how \nwell the players play by confronting them with the opponents, rotating their \nroles in the matches.\n*/\ntournaments.Measurement = declare(Tournament, {\n\t/** The constructor takes the `game` used in the contest, the `players`\n\tbeing evaluated, the `opponents` used to evaluate them, and the amount of\n\tmatches each player will play (`matchCount`).\n\t*/\n\tconstructor: function Measurement(game, players, opponents, matchCount) {\n\t\tTournament.call(this, game, Array.isArray(players) ? players : [players]);\n\t\tthis.opponents = Array.isArray(opponents) ? opponents : [opponents];\n\t\traiseIf(this.opponents.length < game.players.length - 1, \"Not enough opponents.\");\n\t\tthis.matchCount = isNaN(matchCount) ? game.players.length : +matchCount;\n\t\tthis.__advance__ = this.__matches__().chain(Iterable.repeat(null)).__iter__();\n\t},\n\n\t/** A measurement tournament makes every player play `matchCount` matches \n\tfor each role in the game against all possible combinations of opponents.\n\t*/\n\t__matches__: function __matches__() {\n\t\tvar game = this.game,\n\t\t\tplayerCount = game.players.length,\n\t\t\topponentCombinations = iterable(this.opponents);\n\t\tif (playerCount > 2) {\n\t\t\topponentCombinations = opponentCombinations.product.apply(opponentCombinations, \n\t\t\t\tIterable.repeat(this.opponents, playerCount - 2).toArray());\n\t\t} else {\n\t\t\topponentCombinations = opponentCombinations.map(function (p) {\n\t\t\t\treturn [p];\n\t\t\t});\n\t\t}\n\t\treturn iterable(this.players).product( \n\t\t\tIterable.range(playerCount),\n\t\t\topponentCombinations,\n\t\t\tIterable.range(this.matchCount)).map(function (tuple){\n\t\t\t\tvar players = tuple[2].slice(0);\n\t\t\t\tplayers.splice(tuple[1], 0, tuple[0]);\n\t\t\t\treturn new Match(game, players);\n\t\t\t});\n\t},\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Measurement',\n\t\tserializer: function serialize_Measurement(obj) { //TODO Include statistics.\n\t\t\treturn [obj.game, obj.players, obj.opponents, obj.matchCount];\n\t\t}\n\t}\n}); //// declare Measurement.\n","/** # Elimination\n\nPlayoffs or sudden death kind of contests, also known as \n[elimination tournaments](http://en.wikipedia.org/wiki/Single-elimination_tournament).\nIn this tournaments players get randomly matched in successive brackets, each \nmatch's winner passing to the next round until the final match. Games are \nassumed to have only one winner per match.\n*/\ntournaments.Elimination = declare(Tournament, {\n\t/** The constructor takes the `game` to be played, the `players` and the \n\tamount of matches that make each playoff (`matchCount`, 1 by default).\n\t*/\n\tconstructor: function Elimination(game, players, matchCount) {\n\t\tTournament.call(this, game, players);\n\t\tthis.matchCount = isNaN(matchCount) ? 1 : +matchCount >> 0;\n\t},\n\n\t/** Each bracket is defined by partitioning the `players` in groups of the\n\tsize required by the game (usually two). If there are not enough players,\n\tsome players get reassigned. The bracket includes `matchCount` matches \n\tbetween these participants, rotating roles if possible.\n\t*/\n\t__bracket__: function __bracket__(players) {\n\t\tvar game = this.game,\n\t\t\tmatchCount = this.matchCount,\n\t\t\troleCount = this.game.players.length;\n\t\tplayers = players || this.players;\n\t\tif (players.length < roleCount) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn Iterable.range(0, players.length, roleCount).map(function (i) {\n\t\t\t\tvar participants = Iterable.range(i, i + roleCount).map(function (j) {\n\t\t\t\t\treturn players[j % players.length]; // Fill by repeating players if necessary.\n\t\t\t\t}).toArray();\n\t\t\t\treturn Iterable.range(matchCount).map(function (i) {\n\t\t\t\t\tparticipants.unshift(participants.pop()); // Rotate partipants roles.\n\t\t\t\t\treturn new Match(game, participants);\n\t\t\t\t}).toArray();\n\t\t\t}).toArray();\n\t\t}\n\t},\n\t\n\t/** A playoff is resolved by aggregating the results of all its matches. The\n\twinner of the playoff is the one with the greater result sum.\n\t*/\n\t__playoff__: function __playoff__(matches) {\n\t\tvar playoffResult = {},\n\t\t\tplayers = {};\n\t\tmatches.forEach(function (match) {\n\t\t\tvar matchResult = match.result();\n\t\t\tif (!matchResult) {\n\t\t\t\tthrow new Error('Unfinished match in playoff!');\n\t\t\t}\n\t\t\titerable(match.players).forEach(function (tuple) {\n\t\t\t\tvar role = tuple[0],\n\t\t\t\t\tplayerName = tuple[1].name;\n\t\t\t\tplayoffResult[playerName] = (+playoffResult[playerName] || 0) + matchResult[role];\n\t\t\t\tplayers[playerName] = tuple[1];\n\t\t\t});\n\t\t});\n\t\tvar winnerName = iterable(playoffResult).greater(function (pair) {\n\t\t\treturn pair[1];\n\t\t})[0][0];\n\t\treturn players[winnerName];\n\t},\n\t\n\t/** The elimination tournament runs until there is less players in the next\n\tbracket than the amount required to play the game. Since this amount is \n\tusually two, the contest ends with one player at the top.\n\t*/\n\t__advance__: function __advance__() {\n\t\tif (!this.__matches__ || this.__matches__.length < 1) {\n\t\t\tif (!this.__currentBracket__) { // First bracket.\n\t\t\t\tthis.__currentBracket__ = this.__bracket__(this.players);\n\t\t\t} else if (this.__currentBracket__.length < 1) { // Tournament is finished.\n\t\t\t\treturn null;\n\t\t\t} else { // Second and on brackets.\n\t\t\t\tvar players = this.__currentBracket__.map(this.__playoff__);\n\t\t\t\tthis.__currentBracket__ = this.__bracket__(players);\n\t\t\t}\n\t\t\tthis.__matches__ = iterable(this.__currentBracket__).flatten().toArray();\n\t\t}\t\n\t\treturn this.__matches__.shift();\n\t},\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Elimination',\n\t\tserializer: function serialize_Elimination(obj) { //TODO Include statistics.\n\t\t\treturn [obj.game, obj.players, obj.matchCount];\n\t\t}\n\t}\n}); //// declare Elimination.\n"]}