<!DOCTYPE html><html lang="en"><head><title>src\Game</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src\Game"><meta name="groc-project-path" content="src\Game.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src\Game.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h2 id="classgame">Class <code>Game</code></h2>

<p>The class <code>ludorum.Game</code> is the base type for all games.</p></div></div><div class="code"><div class="wrapper"><span class="kd">var</span> <span class="nx">Game</span> <span class="o">=</span> <span class="nx">exports</span><span class="p">.</span><span class="nx">Game</span> <span class="o">=</span> <span class="nx">declare</span><span class="p">({</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Its constructor takes the active player/s. A player is active if and 
only if it can move. The argument may be either a player's name (string) or 
an array of players' names. It is used to initialize <code>Game.activePlayers</code>, 
an array with the active players' names.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">constructor</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">Game</span><span class="p">(</span><span class="nx">activePlayers</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">activePlayers</span> <span class="o">=</span> <span class="o">!</span><span class="nx">activePlayers</span> <span class="o">?</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">:</span> 
      <span class="p">(</span><span class="o">!</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">activePlayers</span><span class="p">)</span> <span class="o">?</span> <span class="p">[</span><span class="nx">activePlayers</span><span class="p">]</span> <span class="o">:</span> <span class="nx">activePlayers</span><span class="p">);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The game's name at <code>Game.name</code> is used mainly for displaying purposes.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The game players are specified in the class property <code>Game.players</code>, an 
array of role names (strings), that the players can assume in a match of 
this game. For example: <code>"Xs"</code> and <code>"Os"</code> in TicTacToe, or <code>"Whites"</code> and 
<code>"Blacks"</code> in Chess.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">players</span><span class="o">:</span> <span class="p">[],</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The moves of each active player are calculated by <code>Game.moves()</code>. This 
method returns an object with every active player related to the moves each
can make in this turn. For example: </p>

<pre><code>{ Player1: ['Rock', 'Paper', 'Scissors'], 
Player2: ['Rock', 'Paper', 'Scissors'] }
</code></pre>

<p>If the game has finished then a falsy value must be returned (<code>null</code> is 
recommended).</p></div></div><div class="code"><div class="wrapper">  <span class="nx">moves</span><span class="o">:</span> <span class="nx">unimplemented</span><span class="p">(</span><span class="s2">&quot;Game&quot;</span><span class="p">,</span> <span class="s2">&quot;moves&quot;</span><span class="p">),</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Once the players have chosen their moves, the method <code>Game.next(moves)</code>
is used to perform the given moves. It returns a new game instance with the
resulting state. The moves object should have a move for each active player.
For example:</p>

<pre><code>{ Player1: 'Rock', Player2: 'Paper' }
</code></pre>

<p>There isn't a default implementation, so it must be overriden. It is 
strongly advised to check if the moves argument has valid moves.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">next</span><span class="o">:</span> <span class="nx">unimplemented</span><span class="p">(</span><span class="s2">&quot;Game&quot;</span><span class="p">,</span> <span class="s2">&quot;next&quot;</span><span class="p">),</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the game is finished the result of the game is calculated with 
<code>Game.result()</code>. It returns an object with every player in the game related 
to a number. This number must be positive if the player wins, negative if 
the player loses or zero if the game is a tie. For example:</p>

<pre><code>{ Player1: -1, Player2: +1 }
</code></pre>

<p>If the game is not finished, this function must return a falsy value (<code>null</code>
is recommended).</p></div></div><div class="code"><div class="wrapper">  <span class="nx">result</span><span class="o">:</span> <span class="nx">unimplemented</span><span class="p">(</span><span class="s2">&quot;Game&quot;</span><span class="p">,</span> <span class="s2">&quot;result&quot;</span><span class="p">),</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Some games may assign scores to the players in a finished game. This may
differ from the result, since the score sign doesn't have to indicate 
victory or defeat. For example:</p>

<pre><code>result: { Player1: -1, Player2: +1 }
scores: { Player1: 4, Player2: 15 }
</code></pre>

<p>The method <code>Game.scores()</code> returns the scores if such is the case. By 
default, it return the same that <code>Game.result()</code> does.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">scores</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">scores</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">results</span><span class="p">();</span>
  <span class="p">},</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In incomplete or imperfect information games all players have different
access to the game state data. <code>Game.view(player)</code> returns a modified 
version of this game, that shows only the information from the perspective 
of the given player. The other information is modelled as aleatory 
variables.</p>

<p>In this way searches in the game tree can be performed without revealing to
the automatic player information it shouldn't have access to (a.k.a 
<em>cheating</em>).</p></div></div><div class="code"><div class="wrapper">  <span class="nx">view</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">view</span><span class="p">(</span><span class="nx">player</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">},</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="player-information">Player information</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Game.isActive(player...)</code> checks if the given players are all active.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">isActive</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">isActive</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">activePlayers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In most games there is only one active player per turn. The method
<code>Game.activePlayer()</code> returns that active player's role if there is one and 
only one, else it raises an error.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">activePlayer</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">activePlayer</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">activePlayers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="nx">raiseIf</span><span class="p">(</span><span class="nx">len</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;There is no active player.&#39;</span><span class="p">);</span>
    <span class="nx">raiseIf</span><span class="p">(</span><span class="nx">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;More than one player is active.&#39;</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">activePlayers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All players in a game are assumed to be opponents. The method 
<code>Game.opponents(players=activePlayers)</code> returns an array with the opponent 
roles of the given players, or of the active players by default. If not all
players are opponents this method can be overriden.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">opponents</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">opponents</span><span class="p">(</span><span class="nx">players</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">players</span> <span class="o">=</span> <span class="nx">players</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">activePlayers</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">players</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Since most games have only two players, the method 
<code>Game.opponent(player=activePlayer)</code> conveniently returns the opponent of 
the given player, or the active player by default.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">opponent</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">opponent</span><span class="p">(</span><span class="nx">player</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">playerIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">player</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">activePlayer</span><span class="p">());</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">[(</span><span class="nx">playerIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">.</span><span class="nx">length</span><span class="p">];</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="game-flow">Game flow</h3></div></div><div class="code"><div class="wrapper">  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Since <code>Game.next()</code> expects a moves object, the method 
<code>Game.perform(move, player=activePlayer, ...)</code> pretends to simplify simpler
game mechanics. It performs the given moves for the given players 
(activePlayer by default) and returns the next game state.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">perform</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">perform</span><span class="p">(</span><span class="nx">move</span><span class="p">,</span> <span class="nx">player</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">player</span> <span class="o">=</span> <span class="nx">player</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">activePlayer</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">moves</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nx">moves</span><span class="p">[</span><span class="nx">player</span><span class="p">]</span> <span class="o">=</span> <span class="nx">move</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">player</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">activePlayer</span><span class="p">();</span>
      <span class="nx">moves</span><span class="p">[</span><span class="nx">player</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">moves</span><span class="p">);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="result-functions">Result functions</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The maximum and minimum results may be useful and even required by some 
game search algorithm. To expose these values, <code>Game.resultBounds()</code> returns
an array with first the minimum and then the maximum. Most game have one type 
of victory (+1) and one type of defeat (-1). Thats why <code>Game.resultBounds()</code>
returns [-1,+1] by default. Yet some games can define different bounds by 
overriding it.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">resultBounds</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">resultBounds</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">},</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Most games have victory and defeat results that cancel each other. It is
said that all the victors wins the defeated player loses. Those games are
called <em>zerosum games</em>. The method 
<code>Game.zerosumResult(score, players=activePlayers)</code> builds a game result 
object for a zerosum game. The given score is split between the given 
players (the active players by default), and (-score) is split between their 
opponents.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">zerosumResult</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">zerosumResult</span><span class="p">(</span><span class="nx">score</span><span class="p">,</span> <span class="nx">players</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">players</span> <span class="o">=</span> <span class="o">!</span><span class="nx">players</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">activePlayers</span> <span class="o">:</span> <span class="p">(</span><span class="o">!</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">players</span><span class="p">)</span> <span class="o">?</span> <span class="p">[</span><span class="nx">players</span><span class="p">]</span> <span class="o">:</span> <span class="nx">players</span><span class="p">);</span>
    <span class="nx">score</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="nx">score</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nx">players</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">({}),</span> <span class="nx">player</span><span class="p">,</span>
      <span class="nx">opponentScore</span> <span class="o">=</span> <span class="o">-</span><span class="nx">score</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">players</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">player</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">player</span><span class="p">]</span> <span class="o">=</span> <span class="nx">players</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">player</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">opponentScore</span> <span class="o">:</span> <span class="nx">score</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Game.zerosumResult()</code> has two shorcuts. 
<code>Game.victory(players=activePlayers, score=1)</code> returns the zerosum game 
result with the given players (or the active players by default) as winners,
and their opponents as losers.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">victory</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">victory</span><span class="p">(</span><span class="nx">players</span><span class="p">,</span> <span class="nx">score</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">zerosumResult</span><span class="p">(</span><span class="nx">score</span> <span class="o">||</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">players</span><span class="p">);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>Game.defeat(players=activePlayers, score=-1)</code> returns the zerosum game 
result with the given players (or the active players by default) as losers, 
and their opponents as winners.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">defeat</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">defeat</span><span class="p">(</span><span class="nx">players</span><span class="p">,</span> <span class="nx">score</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">zerosumResult</span><span class="p">(</span><span class="nx">score</span> <span class="o">||</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">players</span><span class="p">);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A tied game must always have the same result for all players. 
<code>Game.draw(players=this.players, score=0)</code> returns the game result of a tied 
game with the given players (or the active players by default) all with the 
same score (zero by default).</p></div></div><div class="code"><div class="wrapper">  <span class="nx">draw</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">players</span><span class="p">,</span> <span class="nx">score</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">score</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span><span class="nx">score</span> <span class="o">||</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nx">players</span> <span class="o">=</span> <span class="nx">players</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">({});</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">player</span> <span class="k">in</span> <span class="nx">players</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">players</span><span class="p">[</span><span class="nx">player</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">score</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="conversions-amp-presentations">Conversions &amp; presentations</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Many methods are based in the serialization of the game instances. The
abstract method <code>Game.__serialize__()</code> should returns an array, where the 
first element should be the name of the game, and the rest are the arguments
to call the game's constructor in order to rebuild this game's state.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">__serialize__</span><span class="o">:</span> <span class="nx">unimplemented</span><span class="p">(</span><span class="s2">&quot;Game&quot;</span><span class="p">,</span> <span class="s2">&quot;__serialize__&quot;</span><span class="p">),</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Based on the game's serialization, <code>Game.clone()</code> creates a copy of this 
game state.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">clone</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">clone</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">__serialize__</span><span class="p">();</span>
    <span class="nx">args</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span> <span class="c1">// Remove first element (game&#39;s name).</span>
    <span class="k">return</span> <span class="k">new</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">bind</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">constructor</span><span class="p">,</span> <span class="nx">args</span><span class="p">))();</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Some algorithms require an identifier for each game state, in order to 
store them in caches or hashes. <code>Game.identifier()</code> calculates a string that 
uniquely identifies this game state, based on the game's serialization.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">identifier</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">identifier</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">__serialize__</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">args</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span> <span class="o">+</span> <span class="nx">args</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
  <span class="p">},</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The default string representation of a Game (i.e. <code>Game.toString()</code>) is
also based on the serialization. Changing this is not recommended.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">toString</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">__serialize__</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">args</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span> <span class="o">+</span><span class="s1">&#39;(&#39;</span><span class="o">+</span> <span class="nx">args</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;)&#39;</span><span class="p">;</span>
  <span class="p">},</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The default JSON representation (i.e. <code>Game.toJSON()</code>) is a straight 
JSON stringification of the serialization. It may be used to transfer the 
game state between server and client, frames or workers.</p></div></div><div class="code"><div class="wrapper">  <span class="nx">toJSON</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">toJSON</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">__serialize__</span><span class="p">());</span>
  <span class="p">},</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The static counterpart of <code>Game.toJSON</code> is <code>Game.fromJSON(data)</code>, which
creates a new instance of this game from the given JSON. The function in the 
Game abstract class finds the proper constructor with the game name and 
calls it.</p></div></div><div class="code"><div class="wrapper">  <span class="s2">&quot;static fromJSON&quot;</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">fromJSON</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">data</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">raiseIf</span><span class="p">(</span><span class="o">!</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">||</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Invalid JSON data: &quot;</span><span class="o">+</span> <span class="nx">data</span> <span class="o">+</span><span class="s2">&quot;!&quot;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">cons</span> <span class="o">=</span> <span class="nx">games</span><span class="p">[</span><span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
    <span class="nx">raiseIf</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">cons</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">,</span> <span class="s2">&quot;Unknown game &#39;&quot;</span><span class="p">,</span> <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;&#39;!&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">cons</span><span class="p">.</span><span class="nx">fromJSON</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">cons</span><span class="p">.</span><span class="nx">fromJSON</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="c1">// Call game&#39;s fromJSON.</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">basis</span><span class="p">.</span><span class="nx">global</span><span class="p">;</span> <span class="c1">// Call game&#39;s constructor.</span>
      <span class="k">return</span> <span class="k">new</span> <span class="p">(</span><span class="nx">cons</span><span class="p">.</span><span class="nx">bind</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">cons</span><span class="p">,</span> <span class="nx">data</span><span class="p">))();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">});</span> <span class="c1">// declare Game.</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The namespace <code>ludorum.games</code> contains all game implementations (as Game 
subclasses) provided by this library.</p></div></div><div class="code"><div class="wrapper"><span class="kd">var</span> <span class="nx">games</span> <span class="o">=</span> <span class="nx">exports</span><span class="p">.</span><span class="nx">games</span> <span class="o">=</span> <span class="p">{};</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Serialized simultaneous games. //////////////////////////////////////////////</p></div></div><div class="code"><div class="wrapper">  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>static Game.serialized():
    Builds a serialized version of this game, converting a simultaneous game to 
    an alternated turn based game.</p></div></div><div class="code"><div class="wrapper"><span class="nx">Game</span><span class="p">.</span><span class="nx">serialized</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">serialized</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">super_moves</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">moves</span><span class="p">,</span>
    <span class="nx">super_next</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">declare</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Game.serialized.moves():
    Returns the moves of the player deemed as the active player, if 
    there are any moves.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">moves</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">moves</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fixedMoves</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">__fixedMoves__</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">__fixedMoves__</span> <span class="o">=</span> <span class="p">{}),</span>
        <span class="nx">allMoves</span> <span class="o">=</span> <span class="nx">super_moves</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
        <span class="nx">moves</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="nx">activePlayer</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">activePlayers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">fixedMoves</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">activePlayers</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
          <span class="nx">activePlayer</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">activePlayers</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">activePlayer</span> <span class="o">&amp;&amp;</span> <span class="nx">allMoves</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">moves</span><span class="p">[</span><span class="nx">activePlayer</span><span class="p">]</span> <span class="o">=</span> <span class="nx">allMoves</span><span class="p">[</span><span class="nx">activePlayer</span><span class="p">];</span>
        <span class="k">return</span> <span class="nx">moves</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">},</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Game.serialized.next(moves):
    If with the given move all active players in the real game state
    have moves, then the actual game advances. Else the next player 
    that has to move becomes active.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">next</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">moves</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">nextFixedMoves</span> <span class="o">=</span> <span class="nx">copy</span><span class="p">({},</span> <span class="k">this</span><span class="p">.</span><span class="nx">fixedMoves</span> <span class="o">||</span> <span class="p">{},</span> <span class="nx">moves</span><span class="p">),</span>
        <span class="nx">allMoved</span> <span class="o">=</span> <span class="nx">iterable</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">players</span><span class="p">).</span><span class="nx">all</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">nextFixedMoves</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
          <span class="p">}),</span>
        <span class="nx">result</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">allMoved</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">super_next</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">nextFixedMoves</span><span class="p">);</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">fixedMoves</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">fixedMoves</span> <span class="o">=</span> <span class="nx">nextFixedMoves</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">};</span> <span class="c1">// Game.serialized</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cached games. ///////////////////////////////////////////////////////////////</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>static Game.cached():
    Returns a derived constructor is returned that caches the moves and result 
    methods. The next() method is not cached because it may lead to memory
    leaks or overload.</p></div></div><div class="code"><div class="wrapper"><span class="nx">Game</span><span class="p">.</span><span class="nx">cached</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">cached</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">super_moves</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">moves</span><span class="p">,</span>
    <span class="nx">super_result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">result</span><span class="p">,</span>
    <span class="nx">super_next</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">declare</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Game.cached.moves():
    The first time it is called, delegates to game.moves(), and 
    keeps the result for future calls.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">moves</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">moves</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">super_moves</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">moves</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">cachedMoves</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Replace moves() method with cached version.</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">},</span>
    </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Game.cached.result():
    The first time it is called, delegates to game.result(), and 
    keeps the result for future calls.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">result</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">result</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">super_result</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">cachedResult</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Replace result() method with cached version.</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">};</span> <span class="c1">// Game.cached</span></div></div></div></div></body></html>