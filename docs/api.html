<!DOCTYPE html>
<html><head>
	<title>ludorum</title>
	<link rel="stylesheet" href="api.css">
</head><body>
	<div id="api_index">
		<h3><a href="#">Index</a></h3>
		<ul><li><span class=""><a href="#aleatories"><code>aleatories</code></a></span><ul><li><span class="item_new"><a href="#aleatories.Dice"><code>Dice</code></a></span><ul><li><span class=""><a href="#aleatories.Dice.base"><code>base</code></a></span></li><li><span class=""><a href="#aleatories.Dice.distribution"><code>distribution</code></a></span></li></ul></li></ul></li><li><span class="item_new"><a href="#Aleatory"><code>Aleatory</code></a></span><ul><li><span class=""><a href="#Aleatory.distribution"><code>distribution</code></a></span></li><li><span class=""><a href="#Aleatory.instantiate"><code>instantiate</code></a></span></li><li><span class=""><a href="#Aleatory.value"><code>value</code></a></span></li></ul></li><li><span class="item_new"><a href="#Game"><code>Game</code></a></span><ul><li><span class=""><a href="#Game.activePlayer"><code>activePlayer</code></a></span></li><li><span class=""><a href="#Game.activePlayers"><code>activePlayers</code></a></span></li><li><span class=""><a href="#Game.args"><code>args</code></a></span></li><li><span class="item_static"><a href="#Game.cached"><code>cached</code></a></span><ul><li><span class=""><a href="#Game.cached.moves"><code>moves</code></a></span></li><li><span class=""><a href="#Game.cached.result"><code>result</code></a></span></li></ul></li><li><span class=""><a href="#Game.clone"><code>clone</code></a></span></li><li><span class=""><a href="#Game.defeat"><code>defeat</code></a></span></li><li><span class=""><a href="#Game.doMove"><code>doMove</code></a></span></li><li><span class=""><a href="#Game.draw"><code>draw</code></a></span></li><li><span class=""><a href="#Game.identifier"><code>identifier</code></a></span></li><li><span class=""><a href="#Game.isActive"><code>isActive</code></a></span></li><li><span class=""><a href="#Game.moves"><code>moves</code></a></span></li><li><span class=""><a href="#Game.name"><code>name</code></a></span></li><li><span class=""><a href="#Game.next"><code>next</code></a></span></li><li><span class=""><a href="#Game.opponent"><code>opponent</code></a></span></li><li><span class=""><a href="#Game.opponents"><code>opponents</code></a></span></li><li><span class=""><a href="#Game.players"><code>players</code></a></span></li><li><span class=""><a href="#Game.result"><code>result</code></a></span></li><li><span class=""><a href="#Game.resultBounds"><code>resultBounds</code></a></span></li><li><span class="item_static"><a href="#Game.serialized"><code>serialized</code></a></span><ul><li><span class=""><a href="#Game.serialized.moves"><code>moves</code></a></span></li><li><span class=""><a href="#Game.serialized.next"><code>next</code></a></span></li></ul></li><li><span class=""><a href="#Game.toString"><code>toString</code></a></span></li><li><span class=""><a href="#Game.victory"><code>victory</code></a></span></li><li><span class=""><a href="#Game.zerosumResult"><code>zerosumResult</code></a></span></li></ul></li><li><span class=""><a href="#games"><code>games</code></a></span><ul><li><span class="item_new"><a href="#games.__Predefined__"><code>__Predefined__</code></a></span><ul><li><span class=""><a href="#games.__Predefined__.__results__"><code>__results__</code></a></span></li><li><span class=""><a href="#games.__Predefined__.moves"><code>moves</code></a></span></li><li><span class=""><a href="#games.__Predefined__.next"><code>next</code></a></span></li><li><span class=""><a href="#games.__Predefined__.players"><code>players</code></a></span></li><li><span class=""><a href="#games.__Predefined__.result"><code>result</code></a></span></li></ul></li><li><span class="item_new"><a href="#games.Choose2Win"><code>Choose2Win</code></a></span><ul><li><span class=""><a href="#games.Choose2Win.moves"><code>moves</code></a></span></li><li><span class=""><a href="#games.Choose2Win.next"><code>next</code></a></span></li><li><span class=""><a href="#games.Choose2Win.players"><code>players</code></a></span></li><li><span class=""><a href="#games.Choose2Win.result"><code>result</code></a></span></li></ul></li><li><span class="item_new"><a href="#games.Mancala"><code>Mancala</code></a></span><ul><li><span class=""><a href="#games.Mancala.countRemainingSeeds"><code>countRemainingSeeds</code></a></span></li><li><span class=""><a href="#games.Mancala.emptyCapture"><code>emptyCapture</code></a></span></li><li><span class="item_static"><a href="#games.Mancala.heuristics"><code>heuristics</code></a></span><ul><li><span class=""><a href="#games.Mancala.heuristics.defaultHeuristic"><code>defaultHeuristic</code></a></span></li><li><span class=""><a href="#games.Mancala.heuristics.heuristicFromWeights"><code>heuristicFromWeights</code></a></span></li></ul></li><li><span class=""><a href="#games.Mancala.houses"><code>houses</code></a></span></li><li><span class=""><a href="#games.Mancala.makeBoard"><code>makeBoard</code></a></span></li><li><span class=""><a href="#games.Mancala.moves"><code>moves</code></a></span></li><li><span class=""><a href="#games.Mancala.next"><code>next</code></a></span></li><li><span class=""><a href="#games.Mancala.nextSquare"><code>nextSquare</code></a></span></li><li><span class=""><a href="#games.Mancala.oppositeHouse"><code>oppositeHouse</code></a></span></li><li><span class=""><a href="#games.Mancala.players"><code>players</code></a></span></li><li><span class=""><a href="#games.Mancala.result"><code>result</code></a></span></li><li><span class=""><a href="#games.Mancala.resultBounds"><code>resultBounds</code></a></span></li><li><span class=""><a href="#games.Mancala.store"><code>store</code></a></span></li></ul></li><li><span class="item_new"><a href="#games.OddsAndEvens"><code>OddsAndEvens</code></a></span><ul><li><span class=""><a href="#games.OddsAndEvens.moves"><code>moves</code></a></span></li><li><span class=""><a href="#games.OddsAndEvens.next"><code>next</code></a></span></li><li><span class=""><a href="#games.OddsAndEvens.players"><code>players</code></a></span></li><li><span class=""><a href="#games.OddsAndEvens.result"><code>result</code></a></span></li></ul></li><li><span class="item_new"><a href="#games.Pig"><code>Pig</code></a></span><ul><li><span class=""><a href="#games.Pig.goal"><code>goal</code></a></span></li><li><span class=""><a href="#games.Pig.moves"><code>moves</code></a></span></li><li><span class=""><a href="#games.Pig.next"><code>next</code></a></span></li><li><span class=""><a href="#games.Pig.players"><code>players</code></a></span></li><li><span class=""><a href="#games.Pig.result"><code>result</code></a></span></li></ul></li><li><span class="item_new"><a href="#games.TicTacToe"><code>TicTacToe</code></a></span><ul><li><span class="item_static"><a href="#games.TicTacToe.heuristics"><code>heuristics</code></a></span><ul><li><span class=""><a href="#games.TicTacToe.heuristics.defaultHeuristic"><code>defaultHeuristic</code></a></span></li><li><span class=""><a href="#games.TicTacToe.heuristics.heuristicFromWeights"><code>heuristicFromWeights</code></a></span></li></ul></li><li><span class=""><a href="#games.TicTacToe.moves"><code>moves</code></a></span></li><li><span class=""><a href="#games.TicTacToe.next"><code>next</code></a></span></li><li><span class=""><a href="#games.TicTacToe.players"><code>players</code></a></span></li><li><span class=""><a href="#games.TicTacToe.result"><code>result</code></a></span></li><li><span class=""><a href="#games.TicTacToe.toString"><code>toString</code></a></span></li></ul></li><li><span class="item_new"><a href="#games.ToadsAndFrogs"><code>ToadsAndFrogs</code></a></span><ul><li><span class="item_static"><a href="#games.ToadsAndFrogs.board"><code>board</code></a></span></li><li><span class=""><a href="#games.ToadsAndFrogs.moves"><code>moves</code></a></span></li><li><span class=""><a href="#games.ToadsAndFrogs.next"><code>next</code></a></span></li><li><span class=""><a href="#games.ToadsAndFrogs.players"><code>players</code></a></span></li><li><span class=""><a href="#games.ToadsAndFrogs.results"><code>results</code></a></span></li><li><span class=""><a href="#games.ToadsAndFrogs.toString"><code>toString</code></a></span></li></ul></li></ul></li><li><span class="item_new"><a href="#Match"><code>Match</code></a></span><ul><li><span class=""><a href="#Match.decisions"><code>decisions</code></a></span></li><li><span class=""><a href="#Match.events"><code>events</code></a></span></li><li><span class=""><a href="#Match.history"><code>history</code></a></span></li><li><span class=""><a href="#Match.ply"><code>ply</code></a></span></li><li><span class=""><a href="#Match.result"><code>result</code></a></span></li><li><span class=""><a href="#Match.run"><code>run</code></a></span></li><li><span class=""><a href="#Match.state"><code>state</code></a></span></li></ul></li><li><span class="item_new"><a href="#Player"><code>Player</code></a></span><ul><li><span class=""><a href="#Player.__moves__"><code>__moves__</code></a></span></li><li><span class=""><a href="#Player.decision"><code>decision</code></a></span></li><li><span class=""><a href="#Player.participate"><code>participate</code></a></span></li></ul></li><li><span class=""><a href="#players"><code>players</code></a></span><ul><li><span class="item_new"><a href="#players.HeuristicPlayer"><code>HeuristicPlayer</code></a></span><ul><li><span class=""><a href="#players.HeuristicPlayer.decision"><code>decision</code></a></span></li><li><span class=""><a href="#players.HeuristicPlayer.moveEvaluation"><code>moveEvaluation</code></a></span></li><li><span class=""><a href="#players.HeuristicPlayer.stateEvaluation"><code>stateEvaluation</code></a></span></li></ul></li><li><span class="item_new"><a href="#players.MiniMaxPlayer"><code>MiniMaxPlayer</code></a></span><ul><li><span class=""><a href="#players.MiniMaxPlayer.heuristic"><code>heuristic</code></a></span></li><li><span class=""><a href="#players.MiniMaxPlayer.minimax"><code>minimax</code></a></span></li><li><span class=""><a href="#players.MiniMaxPlayer.stateEvaluation"><code>stateEvaluation</code></a></span></li></ul></li><li><span class="item_new"><a href="#players.MonteCarloPlayer"><code>MonteCarloPlayer</code></a></span><ul><li><span class=""><a href="#players.MonteCarloPlayer.simulation"><code>simulation</code></a></span></li><li><span class=""><a href="#players.MonteCarloPlayer.stateEvaluation"><code>stateEvaluation</code></a></span></li></ul></li><li><span class="item_new"><a href="#players.RandomPlayer"><code>RandomPlayer</code></a></span><ul><li><span class=""><a href="#players.RandomPlayer.decision"><code>decision</code></a></span></li></ul></li><li><span class="item_new"><a href="#players.TracePlayer"><code>TracePlayer</code></a></span><ul><li><span class=""><a href="#players.TracePlayer.decision"><code>decision</code></a></span></li></ul></li><li><span class="item_new"><a href="#players.UserInterface"><code>UserInterface</code></a></span><ul><li><span class="item_new"><a href="#players.UserInterface.BasicHTMLInterface"><code>BasicHTMLInterface</code></a></span><ul><li><span class=""><a href="#players.UserInterface.BasicHTMLInterface.display"><code>display</code></a></span></li></ul></li><li><span class=""><a href="#players.UserInterface.display"><code>display</code></a></span></li><li><span class="item_new"><a href="#players.UserInterface.KineticJSInterface"><code>KineticJSInterface</code></a></span></li><li><span class=""><a href="#players.UserInterface.onBegin"><code>onBegin</code></a></span></li><li><span class=""><a href="#players.UserInterface.onEnd"><code>onEnd</code></a></span></li><li><span class=""><a href="#players.UserInterface.onMove"><code>onMove</code></a></span></li><li><span class=""><a href="#players.UserInterface.perform"><code>perform</code></a></span></li></ul></li><li><span class="item_new"><a href="#players.UserInterfacePlayer"><code>UserInterfacePlayer</code></a></span><ul><li><span class=""><a href="#players.UserInterfacePlayer.decision"><code>decision</code></a></span></li><li><span class=""><a href="#players.UserInterfacePlayer.perform"><code>perform</code></a></span></li></ul></li></ul></li><li><span class="item_new"><a href="#Tournament"><code>Tournament</code></a></span><ul><li><span class=""><a href="#Tournament.account"><code>account</code></a></span></li><li><span class=""><a href="#Tournament.events"><code>events</code></a></span></li><li><span class=""><a href="#Tournament.game"><code>game</code></a></span></li><li><span class=""><a href="#Tournament.matches"><code>matches</code></a></span></li><li><span class=""><a href="#Tournament.players"><code>players</code></a></span></li><li><span class=""><a href="#Tournament.run"><code>run</code></a></span></li><li><span class=""><a href="#Tournament.statistics"><code>statistics</code></a></span></li></ul></li><li><span class=""><a href="#tournaments"><code>tournaments</code></a></span><ul><li><span class="item_new"><a href="#tournaments.Measurement"><code>Measurement</code></a></span><ul><li><span class=""><a href="#tournaments.Measurement.matches"><code>matches</code></a></span></li></ul></li><li><span class="item_new"><a href="#tournaments.RoundRobin"><code>RoundRobin</code></a></span><ul><li><span class=""><a href="#tournaments.RoundRobin.matches"><code>matches</code></a></span></li></ul>
	</div>
	<div id="api_detail">
		<header>
			<h1>ludorum</h1>
			<p>A board game implementation library, focusing on artificial intelligence.</p>
		</header>
	
		<div>
			<h4><span class="">
				<a name="aleatories"></a>
				<code>aleatories:</code>
			</span></h4>
			
				<p>Bundle of random game states (i.e. Aleatory subclasses) and related
definitions.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="aleatories.Dice"></a>
				<code>new aleatories.Dice(name, base=6, random=basis.Randomness.DEFAULT):</code>
			</span></h4>
			
				<p>Simple uniform random variable with values in [1, base].</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="aleatories.Dice.base"></a>
				<code>aleatories.Dice.base=6:</code>
			</span></h4>
			
				<p>Amount of different values this dice can take.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="aleatories.Dice.distribution"></a>
				<code>aleatories.Dice.distribution():</code>
			</span></h4>
			
				<p>Values from 1 to this.base, with uniform probabilities.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="Aleatory"></a>
				<code>new Aleatory(next, random=basis.Randomness.DEFAULT):</code>
			</span></h4>
			
				<p>Base constructor for a aleatory game state.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Aleatory.distribution"></a>
				<code>Aleatory.distribution():</code>
			</span></h4>
			
				<p>Computes the histogram for the random variables on which this aleatory
depends, as an iterable of pairs [value, probability]. Not implemented
by default.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Aleatory.instantiate"></a>
				<code>Aleatory.instantiate():</code>
			</span></h4>
			
				<p>Calls this.next() callback with a random value and returns its result.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Aleatory.value"></a>
				<code>Aleatory.value():</code>
			</span></h4>
			
				<p>Calculates a random value for this aleatory.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="Game"></a>
				<code>new Game(activePlayers=first player):</code>
			</span></h4>
			
				<p>Base abstract class of games.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.activePlayer"></a>
				<code>Game.activePlayer():</code>
			</span></h4>
			
				<p>Returns the active player's role if there is one and only one, else
raises an error. This is convenient for AI algorithms that only
support games with one active player at each ply.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.activePlayers"></a>
				<code>Game.activePlayers:</code>
			</span></h4>
			
				<p>The players that can move in this turn.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.args"></a>
				<code>Game.args():</code>
			</span></h4>
			
				<p>Returns an array, where the first element should be the name of the
game, and the rest the arguments to call the game's constructor in order
to rebuild this game's state. Not implemented, so please override.</p>
			
		</div>
	
		<div>
			<h4><span class="item_static">
				<a name="Game.cached"></a>
				<code>static Game.cached():</code>
			</span></h4>
			
				<p>Returns a derived constructor is returned that caches the moves and result
methods. The next() method is not cached because it may lead to memory
leaks or overload.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.cached.moves"></a>
				<code>Game.cached.moves():</code>
			</span></h4>
			
				<p>The first time it is called, delegates to game.moves(), and
keeps the result for future calls.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.cached.result"></a>
				<code>Game.cached.result():</code>
			</span></h4>
			
				<p>The first time it is called, delegates to game.result(), and
keeps the result for future calls.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.clone"></a>
				<code>Game.clone():</code>
			</span></h4>
			
				<p>Creates a copy of this game state. Uses this.arguments().</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.defeat"></a>
				<code>Game.defeat(players=activePlayers, score=-1):</code>
			</span></h4>
			
				<p>Returns the zerosum game result with the given players (or the
active players by default) as losers, and their opponents as
winners.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.doMove"></a>
				<code>Game.doMove(move, player=activePlayer):</code>
			</span></h4>
			
				<p>Performs a move of a single player and returns the next game state.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.draw"></a>
				<code>Game.draw(players=this.players, score=0):</code>
			</span></h4>
			
				<p>Returns the game result of a tied game with the given players (or
the active players by default) all with the same score.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.identifier"></a>
				<code>Game.identifier():</code>
			</span></h4>
			
				<p>Calculates a string that uniquely identifies this game state. Useful
for storing it in hash tables. By default returns this.arguments() in
JSON.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.isActive"></a>
				<code>Game.isActive(player...):</code>
			</span></h4>
			
				<p>Checks if the given players are all active.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.moves"></a>
				<code>Game.moves():</code>
			</span></h4>
			
				<p>Returns an object with every active player related to the moves each
can make in this turn. If there are no moves available for any
active player the game is assumed to be finished.</p>
			
				<p>If the game has random variables to be instantiated, they are
returned as members of this object (with RandomVariable instances as
values).</p>
			
				<p>Warning! The base implementation returns no moves.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.name"></a>
				<code>Game.name:</code>
			</span></h4>
			
				<p>The game's name as a string, for displaying purposes.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.next"></a>
				<code>Game.next(moves):</code>
			</span></h4>
			
				<p>Performs the given moves and returns a new game instance with the
resulting state. The moves object should have a move for each active
player.</p>
			
				<p>If the game has random variables, their instantiation can be added
to the moves object. Else the function must instantiate them, before
returning the next game state.</p>
			
				<p>Note: it is strongly advised to double check the moves object.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.opponent"></a>
				<code>Game.opponent(player=activePlayer):</code>
			</span></h4>
			
				<p>Returns the opponent of the given player, or the active player by
default. This assumes there are only two players in the game, and
only one active player per turn.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.opponents"></a>
				<code>Game.opponents(players=activePlayers):</code>
			</span></h4>
			
				<p>Return an array with the opponent roles of the given players, or of
the active players by default. In this implementation the opponents
are all the other players, but this can be overriden.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.players"></a>
				<code>Game.players:</code>
			</span></h4>
			
				<p>An array of role names (strings), that the players can assume in a
match of this game. For example: &quot;Xs&quot; and &quot;Os&quot; in TicTacToe, or
&quot;Whites&quot; and &quot;Blacks&quot; in Chess.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.result"></a>
				<code>Game.result():</code>
			</span></h4>
			
				<p>If the game is finished the result of the game is an object with
every player in the game related to a number. This number must be
positive if the player wins, negative if the player loses or zero
if the game is a tie. If the game is not finished, this function
returns null.</p>
			
				<p>Warning! The base implementation declares a defeat if the active
players have no moves, with their opponents as winners.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.resultBounds"></a>
				<code>Game.resultBounds():</code>
			</span></h4>
			
				<p>Returns an array with the minimum and the maximum results a player
can have in this game. By default return =[-1,+1].</p>
			
		</div>
	
		<div>
			<h4><span class="item_static">
				<a name="Game.serialized"></a>
				<code>static Game.serialized():</code>
			</span></h4>
			
				<p>Builds a serialized version of this game, converting a simultaneous game to
an alternated turn based game.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.serialized.moves"></a>
				<code>Game.serialized.moves():</code>
			</span></h4>
			
				<p>Returns the moves of the player deemed as the active player, if
there are any moves.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.serialized.next"></a>
				<code>Game.serialized.next(moves):</code>
			</span></h4>
			
				<p>If with the given move all active players in the real game state
have moves, then the actual game advances. Else the next player
that has to move becomes active.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.toString"></a>
				<code>Game.toString():</code>
			</span></h4>
			
				<p>Returns a textual representation of this game state.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.victory"></a>
				<code>Game.victory(players=activePlayers, score=1):</code>
			</span></h4>
			
				<p>Returns the zerosum game result with the given players (or the
active players by default) as winners, and their opponents as
losers.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Game.zerosumResult"></a>
				<code>Game.zerosumResult(score, players=activePlayers):</code>
			</span></h4>
			
				<p>Returns a game result object. The score is split between the given
players (the active	players by default), and (-score) is split
between their opponents.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games"></a>
				<code>games:</code>
			</span></h4>
			
				<p>Bundle of Game subclasses and related definitions.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="games.__Predefined__"></a>
				<code>new games.__Predefined__(activePlayer, results, height=5, width=5):</code>
			</span></h4>
			
				<p>A pseudogame used for testing purposes. It will give width amount of
moves for each player until height moves pass. Then the match is
finished with the given results, or a tie as default.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.__Predefined__.__results__"></a>
				<code>games.__Predefined__.__results__:</code>
			</span></h4>
			
				<p>Default results for __Predefined__: a tie between A and B.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.__Predefined__.moves"></a>
				<code>games.__Predefined__.moves():</code>
			</span></h4>
			
				<p>Moves for a __Predefined__ are numbers from 1 to this.width.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.__Predefined__.next"></a>
				<code>games.__Predefined__.next(moves):</code>
			</span></h4>
			
				<p>Moves are completely irrelevant. They only advance in the match.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.__Predefined__.players"></a>
				<code>games.__Predefined__.players:</code>
			</span></h4>
			
				<p>Default players for __Predefined__: A and B.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.__Predefined__.result"></a>
				<code>games.__Predefined__.result():</code>
			</span></h4>
			
				<p>Returned the predefined results if height is zero or less.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="games.Choose2Win"></a>
				<code>new games.Choose2Win(turns=Infinity, activePlayer=players[0], winner=none):</code>
			</span></h4>
			
				<p>Choose2Win is a silly game indeed. Each turn one of the players can
decide to win, to lose or to pass the turn. It is meant to be used
only for testing Ludorum, since a game can hardly become less
interesting than this.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Choose2Win.moves"></a>
				<code>games.Choose2Win.moves():</code>
			</span></h4>
			
				<p>Moves always are 'win', 'lose', 'pass'.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Choose2Win.next"></a>
				<code>games.Choose2Win.next(moves):</code>
			</span></h4>
			
				<p>Moves must be always 'win', 'lose' or 'pass'.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Choose2Win.players"></a>
				<code>games.Choose2Win.players=['This', 'That']:</code>
			</span></h4>
			
				<p>Players of the dummy game.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Choose2Win.result"></a>
				<code>games.Choose2Win.result():</code>
			</span></h4>
			
				<p>Victory for who chooses to win. Defeat for who chooses to lose. Draw
only when a limit of turns (if given) is met.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="games.Mancala"></a>
				<code>new games.Mancala(activePlayer=&quot;North&quot;, board=makeBoard()):</code>
			</span></h4>
			
				<p>TODO.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.countRemainingSeeds"></a>
				<code>games.Mancala.countRemainingSeeds=true:</code>
			</span></h4>
			
				<p>If true, at the end of the game if a player has seeds on his houses,
those seeds are included in his score.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.emptyCapture"></a>
				<code>games.Mancala.emptyCapture=false:</code>
			</span></h4>
			
				<p>If true, making a capture only moves the active player's seed to his
store. The opponents seeds are not captured.</p>
			
		</div>
	
		<div>
			<h4><span class="item_static">
				<a name="games.Mancala.heuristics"></a>
				<code>static games.Mancala.heuristics:</code>
			</span></h4>
			
				<p>Bundle of heuristic evaluation functions for Mancala.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.heuristics.defaultHeuristic"></a>
				<code>games.Mancala.heuristics.defaultHeuristic(game, player):</code>
			</span></h4>
			
				<p>Default heuristic for Mancala, based on weights for each square.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.heuristics.heuristicFromWeights"></a>
				<code>games.Mancala.heuristics.heuristicFromWeights(weights):</code>
			</span></h4>
			
				<p>Builds an heuristic evaluation function from weights for each square in
the board. The result of the function is the normalized weighted sum.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.houses"></a>
				<code>games.Mancala.houses(player):</code>
			</span></h4>
			
				<p>Returns an array with the indexes of the player's houses in this
game's board.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.makeBoard"></a>
				<code>games.Mancala.makeBoard(seeds=3, houses=6):</code>
			</span></h4>
			
				<p>Builds a board array to use as the game state.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.moves"></a>
				<code>games.Mancala.moves():</code>
			</span></h4>
			
				<p>A move for this game is an index of the square in the board.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.next"></a>
				<code>games.Mancala.next(moves):</code>
			</span></h4>
			
				<p>TODO.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.nextSquare"></a>
				<code>games.Mancala.nextSquare(player, i):</code>
			</span></h4>
			
				<p>Returns the index of the square following i for the given player.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.oppositeHouse"></a>
				<code>games.Mancala.oppositeHouse(player, i):</code>
			</span></h4>
			
				<p>Returns the index of the opposite house of i for the given player,
or a negative if i is not a house of the given player.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.players"></a>
				<code>games.Mancala.players:</code>
			</span></h4>
			
				<p>Players of Mancala are North and South.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.result"></a>
				<code>games.Mancala.result():</code>
			</span></h4>
			
				<p>The game ends when the active player cannot move. The result for
each player is the difference between the seed count of the stores.</p>
			
				<p>If a player has seeds in his side, those are added to his count.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.resultBounds"></a>
				<code>games.Mancala.resultBounds():</code>
			</span></h4>
			
				<p>Result bounds are estimated with the total number of stones in the
board. It is very unlikely to get these result though.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Mancala.store"></a>
				<code>games.Mancala.store(player):</code>
			</span></h4>
			
				<p>Returns the index in this game's board of the player's store.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="games.OddsAndEvens"></a>
				<code>new games.OddsAndEvens(turns=1, points=&lt;cero for both players&gt;):</code>
			</span></h4>
			
				<p>Odds and evens is a very simple simultaneous game. Each turn both
players draw either a one or a two.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.OddsAndEvens.moves"></a>
				<code>games.OddsAndEvens.moves():</code>
			</span></h4>
			
				<p>Moves always are 1 and 2.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.OddsAndEvens.next"></a>
				<code>games.OddsAndEvens.next(moves):</code>
			</span></h4>
			
				<p>The player matching the parity of the moves sum earns a point.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.OddsAndEvens.players"></a>
				<code>games.OddsAndEvens.players=['Evens', 'Odds']:</code>
			</span></h4>
			
				<p>Players for odds and evens.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.OddsAndEvens.result"></a>
				<code>games.OddsAndEvens.result():</code>
			</span></h4>
			
				<p>The winner is the player with more points.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="games.Pig"></a>
				<code>new games.Pig(activePlayer='One', scores, rolls):</code>
			</span></h4>
			
				<p>Pig is a dice betting game, where the active player rolls dice until it
rolls one or passes its turn scoring the sum of previous rolls.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Pig.goal"></a>
				<code>games.Pig.goal=100:</code>
			</span></h4>
			
				<p>Amount of points a player has to reach to win the game.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Pig.moves"></a>
				<code>games.Pig.moves():</code>
			</span></h4>
			
				<p>The active player can either hold and pass the turn, or roll.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Pig.next"></a>
				<code>games.Pig.next(moves):</code>
			</span></h4>
			
				<p>The player matching the parity of the moves sum earns a point.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Pig.players"></a>
				<code>games.Pig.players=['One', 'Two']:</code>
			</span></h4>
			
				<p>Players for Pig.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.Pig.result"></a>
				<code>games.Pig.result():</code>
			</span></h4>
			
				<p>Game finishes when one player reaches or passes the goal score. The
result for each player is the difference between its score and its
opponent's score.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="games.TicTacToe"></a>
				<code>new games.TicTacToe(activePlayer=&quot;Xs&quot;, board='_________'):</code>
			</span></h4>
			
				<p>Constructor of TicTacToe games. The first player is always Xs.</p>
			
		</div>
	
		<div>
			<h4><span class="item_static">
				<a name="games.TicTacToe.heuristics"></a>
				<code>static games.TicTacToe.heuristics:</code>
			</span></h4>
			
				<p>Bundle of heuristic evaluation functions for TicTacToe.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.TicTacToe.heuristics.defaultHeuristic"></a>
				<code>games.TicTacToe.heuristics.defaultHeuristic(game, player):</code>
			</span></h4>
			
				<p>Default heuristic for TicTacToe, based on weights for each square.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.TicTacToe.heuristics.heuristicFromWeights"></a>
				<code>games.TicTacToe.heuristics.heuristicFromWeights(weights):</code>
			</span></h4>
			
				<p>Builds an heuristic evaluation function from weights for each square in the
board. The result of the function is the weighted sum, empty squares being
ignored, opponent squares considered negative.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.TicTacToe.moves"></a>
				<code>games.TicTacToe.moves():</code>
			</span></h4>
			
				<p>Returns the indexes of empty squares in the board.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.TicTacToe.next"></a>
				<code>games.TicTacToe.next(moves):</code>
			</span></h4>
			
				<p>Puts the mark of the active player in the square indicated by the move.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.TicTacToe.players"></a>
				<code>games.TicTacToe.players:</code>
			</span></h4>
			
				<p>There are two roles in this game: &quot;Xs&quot; and &quot;Os&quot;.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.TicTacToe.result"></a>
				<code>games.TicTacToe.result():</code>
			</span></h4>
			
				<p>Returns a victory if any player has three marks in line, a draw if the
board is full, or null otherwise.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.TicTacToe.toString"></a>
				<code>games.TicTacToe.toString():</code>
			</span></h4>
			
				<p>Text version of the TicTacToe board.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="games.ToadsAndFrogs"></a>
				<code>new games.ToadsAndFrogs(activePlayer=&quot;Toads&quot;, board='TTT__FFF'):</code>
			</span></h4>
			
				<p>Constructor of Toads &amp; Frogs games. The first player is always Toads.</p>
			
		</div>
	
		<div>
			<h4><span class="item_static">
				<a name="games.ToadsAndFrogs.board"></a>
				<code>static games.ToadsAndFrogs.board(chips=3, separation=2):</code>
			</span></h4>
			
				<p>Makes a board for Toads &amp; Frogs. This is a single row with the given
number of chips for each player (toads to the left and frogs to the
right) separated by the given number of empty spaces.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.ToadsAndFrogs.moves"></a>
				<code>games.ToadsAndFrogs.moves():</code>
			</span></h4>
			
				<p></p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.ToadsAndFrogs.next"></a>
				<code>games.ToadsAndFrogs.next(moves):</code>
			</span></h4>
			
				<p></p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.ToadsAndFrogs.players"></a>
				<code>games.ToadsAndFrogs.players:</code>
			</span></h4>
			
				<p>There are two roles in this game: &quot;Toads&quot; and &quot;Frogs&quot;.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.ToadsAndFrogs.results"></a>
				<code>games.ToadsAndFrogs.results():</code>
			</span></h4>
			
				<p>The match finishes when one player cannot move, hence losing the game.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="games.ToadsAndFrogs.toString"></a>
				<code>games.ToadsAndFrogs.toString():</code>
			</span></h4>
			
				<p>Prints the game's board.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="Match"></a>
				<code>new Match(game, players):</code>
			</span></h4>
			
				<p>Match objects are game controllers, handling the flow of the turns
between the players. They also provide game events that players and
spectators can be registered to.</p>
			
				<p>The players argument must be either an array of Player objects or an
object with a member for each player with a Player object as value.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Match.decisions"></a>
				<code>Match.decisions(game=current()):</code>
			</span></h4>
			
				<p>Asks the active players in the game to choose their moves. Returns a
future that is resolved when all players have decided.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Match.events"></a>
				<code>Match.events:</code>
			</span></h4>
			
				<p>Event handler for this match. Emitted events are: begin, end, move
&amp; next.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Match.history"></a>
				<code>Match.history:</code>
			</span></h4>
			
				<p>Game state array, from the initial game state to the last.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Match.ply"></a>
				<code>Match.ply():</code>
			</span></h4>
			
				<p>Returns the current ply number.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Match.result"></a>
				<code>Match.result():</code>
			</span></h4>
			
				<p>Returns the results of the current game state.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Match.run"></a>
				<code>Match.run(plys=Infinity):</code>
			</span></h4>
			
				<p>Runs the match the given number of plys or until the game finishes.</p>
			
				<p>The result is a future that gets resolved when running ends.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Match.state"></a>
				<code>Match.state(ply=current):</code>
			</span></h4>
			
				<p>Returns the game state of the given ply. If no one is specified, the
current game state is returned.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="Player"></a>
				<code>new Player(name):</code>
			</span></h4>
			
				<p>A player is an agent that plays a game. This means deciding which
move to make from the set of moves available to the player, each
time the game enables the player to do so.</p>
			
				<p>This is an abstract class that is meant to be extended.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Player.__moves__"></a>
				<code>Player.__moves__(game, player):</code>
			</span></h4>
			
				<p>Get the moves in the game for the player, checks if there are any,
and if such is not the case it raises an error.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Player.decision"></a>
				<code>Player.decision(game, player):</code>
			</span></h4>
			
				<p>Ask the player to make a move in the given name for the given player
(role). The result is the selected move if it can be obtained
synchronously, else a Future is returned.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Player.participate"></a>
				<code>Player.participate(match, role):</code>
			</span></h4>
			
				<p>Called when the player joins a match, in order for the player to prepare
properly. If this implies building another instance of the player
object, it must be returned in order to participate in the match.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players"></a>
				<code>players:</code>
			</span></h4>
			
				<p>Bundle of Player subclasses and related definitions.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="players.HeuristicPlayer"></a>
				<code>new players.HeuristicPlayer(name, random, heuristic):</code>
			</span></h4>
			
				<p>Builds a player that evaluates its moves and chooses one of the best
evaluated.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.HeuristicPlayer.decision"></a>
				<code>players.HeuristicPlayer.decision(game, player):</code>
			</span></h4>
			
				<p>Selects randomly from the best evaluated moves.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.HeuristicPlayer.moveEvaluation"></a>
				<code>players.HeuristicPlayer.moveEvaluation(move, game, player):</code>
			</span></h4>
			
				<p>Calculates a number as the assessment of the given move. The base
implementation calculates the resulting game state and returns the
stateEvaluation of it.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.HeuristicPlayer.stateEvaluation"></a>
				<code>players.HeuristicPlayer.stateEvaluation(game, player):</code>
			</span></h4>
			
				<p>Calculates a number as the assessment of the given game state. The
base implementation returns the result for the player is the game
has results.</p>
			
				<p>Else it returns a random number in [-0.5, 0.5). This is only useful
in testing this framework. Any serious use should override it.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="players.MiniMaxPlayer"></a>
				<code>new players.MiniMaxPlayer(name='MiniMax', heuristic, horizon=3, random=randomness.DEFAULT):</code>
			</span></h4>
			
				<p>Builds a player that chooses its moves using the MiniMax algorithm with
alfa-beta pruning.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.MiniMaxPlayer.heuristic"></a>
				<code>players.MiniMaxPlayer.heuristic(game, player):</code>
			</span></h4>
			
				<p>Game state evaluation used at the leaves of the game search tree that
are not finished games.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.MiniMaxPlayer.minimax"></a>
				<code>players.MiniMaxPlayer.minimax(game, player, depth, alfa, beta):</code>
			</span></h4>
			
				<p>Minimax evaluation of the given game for the given player. If the game
is not finished and the depth is greater than the horizon, the heuristic
is used.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.MiniMaxPlayer.stateEvaluation"></a>
				<code>players.MiniMaxPlayer.stateEvaluation(game, player):</code>
			</span></h4>
			
				<p>Returns the minimax value for the given game and player.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="players.MonteCarloPlayer"></a>
				<code>new players.MonteCarloPlayer(name, random, simulationCount=30):</code>
			</span></h4>
			
				<p>Builds a player that evaluates its moves using Monte-Carlo
simulations (random games).</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.MonteCarloPlayer.simulation"></a>
				<code>players.MonteCarloPlayer.simulation(game, player):</code>
			</span></h4>
			
				<p>Simulates a random match from the given game and returns the result
for the given player.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.MonteCarloPlayer.stateEvaluation"></a>
				<code>players.MonteCarloPlayer.stateEvaluation(game, player):</code>
			</span></h4>
			
				<p>Returns the minimax value for the given game and player.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="players.RandomPlayer"></a>
				<code>new players.RandomPlayer(name, random=basis.Randomness.DEFAULT):</code>
			</span></h4>
			
				<p>Builds a player that chooses its moves randomly.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.RandomPlayer.decision"></a>
				<code>players.RandomPlayer.decision(game, player):</code>
			</span></h4>
			
				<p>Makes the decision completely at random.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="players.TracePlayer"></a>
				<code>new players.TracePlayer(name, trace):</code>
			</span></h4>
			
				<p>Builds a player that makes his decisions based on a trace, a list of
moves to follow.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.TracePlayer.decision"></a>
				<code>players.TracePlayer.decision(game, player):</code>
			</span></h4>
			
				<p>Returns the next move in the trace, or the last one if the trace has
ended.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="players.UserInterface"></a>
				<code>new players.UserInterface(match, config):</code>
			</span></h4>
			
				<p>Base class for user interfaces that display a game and allow one
or more players to play.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="players.UserInterface.BasicHTMLInterface"></a>
				<code>new players.UserInterface.BasicHTMLInterface(match, players, domElement):</code>
			</span></h4>
			
				<p>Simple HTML based UI, that renders the game to the given domElement
using its toHTML method.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.UserInterface.BasicHTMLInterface.display"></a>
				<code>players.UserInterface.BasicHTMLInterface.display(game):</code>
			</span></h4>
			
				<p>When the player is participated of a match, a callback is registered
to the match's events. This method renders the game to HTML at each
step in the match.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.UserInterface.display"></a>
				<code>players.UserInterface.display(game):</code>
			</span></h4>
			
				<p>Renders the game in this user interface. Not implemented, so please
override.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="players.UserInterface.KineticJSInterface"></a>
				<code>new players.UserInterface.KineticJSInterface(match, config):</code>
			</span></h4>
			
				<p>TODO.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.UserInterface.onBegin"></a>
				<code>players.UserInterface.onBegin(players, game):</code>
			</span></h4>
			
				<p>Handler for the 'begin' event of the match.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.UserInterface.onEnd"></a>
				<code>players.UserInterface.onEnd(results, game):</code>
			</span></h4>
			
				<p>Handler for the 'end' event of the match.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.UserInterface.onMove"></a>
				<code>players.UserInterface.onMove(moves, game, next):</code>
			</span></h4>
			
				<p>Handler for the 'move' event of the match.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.UserInterface.perform"></a>
				<code>players.UserInterface.perform(action, player=&lt;active player&gt;):</code>
			</span></h4>
			
				<p>Makes the given player perform the action if the player has a
perform method and is included in this UI's players.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="players.UserInterfacePlayer"></a>
				<code>new players.UserInterfacePlayer(name):</code>
			</span></h4>
			
				<p>Base class of all players that are proxies of user interfaces.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.UserInterfacePlayer.decision"></a>
				<code>players.UserInterfacePlayer.decision(game, player):</code>
			</span></h4>
			
				<p>Returns a future that will be resolved when the perform() method is
called.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="players.UserInterfacePlayer.perform"></a>
				<code>players.UserInterfacePlayer.perform(action):</code>
			</span></h4>
			
				<p>Resolves the decision future. This method is meant to be called by
the user interface.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="Tournament"></a>
				<code>new Tournament(game, players):</code>
			</span></h4>
			
				<p>Base class of all tournament controllers.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Tournament.account"></a>
				<code>Tournament.account(match):</code>
			</span></h4>
			
				<p>Accounts the results of a finished match for the players' score.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Tournament.events"></a>
				<code>Tournament.events:</code>
			</span></h4>
			
				<p>Event handler for this match. Emitted events are: begin,
beforeMatch, afterMatch &amp; end.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Tournament.game"></a>
				<code>Tournament.game:</code>
			</span></h4>
			
				<p>The game played at the tournament.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Tournament.matches"></a>
				<code>Tournament.matches():</code>
			</span></h4>
			
				<p>Returns the matches of this contest in an iterable. In this base
implementation this method raises an exception. It must be overriden.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Tournament.players"></a>
				<code>Tournament.players:</code>
			</span></h4>
			
				<p>An array with the participants in the tournament.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Tournament.run"></a>
				<code>Tournament.run(matches=this.matches()):</code>
			</span></h4>
			
				<p>Plays the given matches. This argument must be an Iterable of
ludorum.Match objects.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Tournament.statistics"></a>
				<code>Tournament.statistics:</code>
			</span></h4>
			
				<p>Tournament statistics. These include the accumulated score for
each player, indexed by name.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="tournaments"></a>
				<code>tournaments:</code>
			</span></h4>
			
				<p>Bundle of Tournament subclasses and related definitions.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="tournaments.Measurement"></a>
				<code>new tournaments.Measurement(game, players, opponents, matchCount=game.players.length):</code>
			</span></h4>
			
				<p>A tournament used to evaluate how well the players play by confronting
them with the opponents, rotating their roles in the matches.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="tournaments.Measurement.matches"></a>
				<code>tournaments.Measurement.matches():</code>
			</span></h4>
			
				<p>Every player plays matchCount matches for each role in the game against
all possible combinations of opponents.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="tournaments.RoundRobin"></a>
				<code>new tournaments.RoundRobin(game, players, matchCount=game.players.length):</code>
			</span></h4>
			
				<p>A tournament that confronts all players against each other rotating
their roles in the matches.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="tournaments.RoundRobin.matches"></a>
				<code>tournaments.RoundRobin.matches():</code>
			</span></h4>
			
				<p>Every player plays matchCount matches for each role in the game against
all the other opponents.</p>
			
		</div>
	
		<footer>ludorum (version 0.1.0) by <a href="mailto:leonardo.val@creatartis.com">Leonardo Val</a>.</footer>
	</div>
</body></html>